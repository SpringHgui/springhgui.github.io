<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>解锁！玩转 HelloGitHub 的新姿势 | dotnet之美</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="解锁！玩转 HelloGitHub 的新姿势" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文不会涉及太多技术细节和源码，请放心食用" />
<meta property="og:description" content="本文不会涉及太多技术细节和源码，请放心食用" />
<link rel="canonical" href="/cnblog/2022/06/01/%E8%A7%A3%E9%94%81%E7%8E%A9%E8%BD%ACHelloGitHub%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF.html" />
<meta property="og:url" content="/cnblog/2022/06/01/%E8%A7%A3%E9%94%81%E7%8E%A9%E8%BD%ACHelloGitHub%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF.html" />
<meta property="og:site_name" content="dotnet之美" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-01T11:44:44+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="解锁！玩转 HelloGitHub 的新姿势" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-01T11:44:44+00:00","datePublished":"2022-06-01T11:44:44+00:00","description":"本文不会涉及太多技术细节和源码，请放心食用","headline":"解锁！玩转 HelloGitHub 的新姿势","mainEntityOfPage":{"@type":"WebPage","@id":"/cnblog/2022/06/01/%E8%A7%A3%E9%94%81%E7%8E%A9%E8%BD%ACHelloGitHub%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF.html"},"url":"/cnblog/2022/06/01/%E8%A7%A3%E9%94%81%E7%8E%A9%E8%BD%ACHelloGitHub%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="dotnet之美" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">dotnet之美</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">解锁！玩转 HelloGitHub 的新姿势</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-06-01T11:44:44+00:00" itemprop="datePublished">Jun 1, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>本文不会涉及太多技术细节和源码，请放心食用</p>
</blockquote>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531210052531-72822628.png" alt="" /></p>

<p>大家好，我是 HelloGitHub 的老荀，好久不见啊！</p>

<p>我在完成 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=MzA5MzYyNzQ0MQ==&amp;scene=1&amp;album_id=1709315979568037891&amp;count=3&amp;from=singlemessage#wechat_redirect">HelloZooKeeper</a> 系列之后，就很少“露面了”。但是我对开源和 HelloGitHub 的热情并没有丝毫的减少。这不，逮着个机会就来输出一波，防止被大家遗忘😂。</p>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531214833380-136099664.png" alt="" /></p>

<p>这次带来的是我写的一款在终端浏览 HelloGitHub 的工具：hg-tui，让你双手不离开键盘就能畅游在 HG 的开源世界。功能如下：</p>

<ul>
  <li>色彩丰富、平铺展示</li>
  <li>关键字搜索月刊往期的项目</li>
  <li>类 Vim 的快捷键操作方式</li>
  <li>一键直达开源项目首页</li>
  <li>支持 Linux、macOS、Windows</li>
</ul>

<blockquote>
  <p>地址：<a href="https://github.com/kaixinbaba/hg-tui">https://github.com/kaixinbaba/hg-tui</a></p>
</blockquote>

<p>下面我将分享自己发起这个开源项目的缘起、构思、再到开发的全部过程，最后分享一下，我通过做这个项目对开源的一些感悟。</p>

<h2 id="一起因">一、起因</h2>

<p>我本职是做 Java 开发，但架不住 Rust 太有意思了！所以最近在学 Rust 恰好前段时间看到 HG 讲解 tui.rs 的<a href="https://mp.weixin.qq.com/s/Bm0Hoy5kCvHqrwUwv_CVag">文章</a>。</p>

<p>看完后手痒得厉害，就写了一篇 tui.rs 入门文章，但感觉还不过瘾就想写一个项目练手。</p>

<p>因为我平时经常上 HelloGitHub 找开源项目，所以就决定用 <code class="language-plaintext highlighter-rouge">tui.rs</code> 做一个终端浏览 HelloGitHub 官网的工具。</p>

<blockquote>
  <p>官网：<a href="https://hellogithub.com/">https://hellogithub.com/</a></p>
</blockquote>

<h2 id="二构思">二、构思</h2>

<p>首先我希望这个应用能有以下功能：</p>

<ul>
  <li>有搜索框，可以按关键词搜索 HelloGitHub 中的任意项目</li>
  <li>通过表格按列展示搜索结果</li>
  <li>既然是终端应用，那操作方式肯定是使用键盘方式，快捷键我采用了一些大家熟知的 Vim 快捷键</li>
  <li>浏览项目的途中，可以随时在浏览器中打开当前浏览的项目</li>
</ul>

<p>有了这些主要功能点的思路，下面就要想想怎么设计一个界面了，我本职工作后端一碰到画界面就头疼，几经周折大概把界面设计成了这样：</p>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531210100579-1058156359.png" alt="" /></p>

<p>又因为是 TUI 界面层级不能太深，所以再多弄个详情页面（用来浏览文字明细）或者弹窗页面（提示消息）就差不多了。</p>

<p>我又想到了 GitHub 为每一种编程语言都设计了一种颜色，我也可以把这些颜色应用在我的项目里，让整个终端界面看起来没那么单调，色彩更丰富。效果如下：</p>

<p>主界面：</p>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531210106545-960475269.png" alt="" /></p>

<p>详情页：</p>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531210111068-1826089399.png" alt="" /></p>

<p>弹窗提示：</p>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531210116267-123114725.png" alt="" /></p>

<p>最后为了向 TUI 妥协，按期数或类别搜索，我是通过使用搜索前缀来和普通关键词搜索作出区别。</p>

<p>上面展示的这些差不多已经是这个项目的全部了</p>

<h2 id="三开发">三、开发</h2>

<h3 id="31-技术选型">3.1 技术选型</h3>

<p>要实现上述的那些功能，就要从 Rust 的生态中选择合适的库了</p>

<p>下面这些是我在这个项目中使用到的：</p>

<ul>
  <li>基础设施：<code class="language-plaintext highlighter-rouge">anyhow</code>、<code class="language-plaintext highlighter-rouge">thiserror</code>、<code class="language-plaintext highlighter-rouge">lazy_static</code>、<code class="language-plaintext highlighter-rouge">better-panic</code></li>
  <li>绘制 UI：<code class="language-plaintext highlighter-rouge">tui</code>、<code class="language-plaintext highlighter-rouge">crossterm</code></li>
  <li>HTTP client：<code class="language-plaintext highlighter-rouge">reqwest</code></li>
  <li>缓存：<code class="language-plaintext highlighter-rouge">cached</code></li>
  <li>HTML 解析：<code class="language-plaintext highlighter-rouge">nipper</code></li>
  <li>工具：<code class="language-plaintext highlighter-rouge">regex</code>、<code class="language-plaintext highlighter-rouge">crossbeam-channel</code></li>
  <li>命令行：<code class="language-plaintext highlighter-rouge">clap</code></li>
</ul>

<p>虽然 Rust 还是编程界的小学生（2011 年启动），但是经过了这些年的发展，生态已经逐渐完善，工具库已经很丰富了。再加上 Rust 是系统级的语言，值得投入时间学习！</p>

<h3 id="32-项目结构">3.2 项目结构</h3>

<p>项目结构规划（非全部）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src
├── app.rs		// 统一管理整个应用的状态
├── cli.rs		// 命令行解析
├── draw.rs		// 绘制 UI
├── events.rs	        // UI 事件、输入事件、通知
├── fetch.rs	        // HTTP 请求
├── main.rs		// 入口
├── parse.rs	       // HTML 解析
├── utils.rs	       // 工具
└── widget 	       // 自定义组件
    ├── ...
</code></pre></div></div>

<p>合理的分文件（目录）开发，可以让每个功能模块 高内聚、低耦合，并且可以很容易地分开进行单元测试。</p>

<p>当然这些文件也不是在项目之初就已经一股脑地建立好的，都是在完善功能的路上一点点添加进来的～</p>

<h3 id="33-主要代码">3.3 主要代码</h3>

<p>因为是基于 <code class="language-plaintext highlighter-rouge">tui.rs</code> 开发的应用，所以主流程肯定是遵循该库的设计的，首先需要定义一个 <code class="language-plaintext highlighter-rouge">App</code> 用来保存整个项目的状态信息。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pub struct App {
    /// 用户输入框
    pub input: InputState,
    /// 内容展示
    pub content: ContentState,
    /// 弹窗提示
    pub popup: PopupState,
    /// 状态栏
    pub statusline: StatusLineState,
    /// 模式
    pub mode: AppMode,
    /// 项目明细子页面
    pub project_detail: ProjectDetailState,
  	...
}
</code></pre></div></div>

<p>每一个状态字段,其实就是对应一个自定义组件.要在 <code class="language-plaintext highlighter-rouge">tui.rs</code> 中实现自定义组件（实现方式也是我自己的理解）也很简单只要三步，我以 <code class="language-plaintext highlighter-rouge">Input</code> 组件为例。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// 用户输入框组件，组件本身没有字段，是一个无状态的对象
/// 无状态对象只关心 UI 怎么绘制，不存储数据
pub struct Input {}

/// 组件的状态，每一个字段就是组件需要存储的数据
#[derive(Debug)]
pub struct InputState {
    input: String,
    active: bool,
    pub mode: SearchMode,
}

/// 最后为 Input 组件实现 StatefulWidget trait
impl StatefulWidget for Input {
    type State = InputState; // 指定关联类型为 InputState
  
    /// area 绘制的区域
    /// buf 缓冲区（可以直接写入字符串，如果要高度定制的话，可以理解为画笔）
    /// state 从这个变量中直接取绘制过程中需要的数据
    fn render(self, area: Rect, buf: &amp;mut Buffer, state: &amp;mut Self::State) {
        // 具体绘制的逻辑
      	...
    }
}
</code></pre></div></div>

<p>只要是面向用户的应用，都会处理各种各样的用户输入（事件）。Rust 中一般都使用 channel 来解耦处理各种各样的事件，再利用 Rust 强大的枚举支持，定义各种各样的事件（用户输入和非用户输入）即可。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// 定义事件枚举
#[derive(Debug, Clone)]
pub enum HGEvent {
    /// 用户事件（键盘事件）
    UserEvent(KeyEvent),
    /// 应用内部组件的通知事件
    NotifyEvent(Notify),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Notify {
    /// 重绘界面
    Redraw,
    /// 退出应用
    Quit,
    /// 弹出窗口展示消息
    Message(Message),
    /// tick，比如一些数据需要每隔一段时间自动更新的（比如：显示的时间）
    Tick,
}

/// 弹窗的消息，分为 错误、警告、提示
#[derive(Debug, Clone, PartialEq)]
pub enum Message {
    Error(String),
    Warn(String),
    Tips(String),
}
</code></pre></div></div>

<p>为了区分用户事件和通知，我使用了两个不同的 channel 分别处理这两类：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lazy_static! {
    /// 因为通知队列希望被应用内部共享，所以使用了 lazy_static 方便使用
    pub static ref NOTIFY: (Sender&lt;HGEvent&gt;, Receiver&lt;HGEvent&gt;) = bounded(1024);
}
</code></pre></div></div>

<p>又因为不同的事件处理，并不应该互相阻塞，所以整个应用采用了最基础的多线程模型来提高性能，这里使用的也是标准库的多线程。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pub fn handle_key_event(event_app: Arc&lt;Mutex&lt;App&gt;&gt;) {
    let (sender, receiver) = unbounded();
    ...
    std::thread::spawn(move || loop {
        // 单独一个线程接收用户事件
        if let Ok(Event::Key(event)) = crossterm::event::read() {
            sender.send(HGEvent::UserEvent(event)).unwrap();
        }
    });
    std::thread::spawn(move || loop {
      	// 单独一个线程处理用户事件
        if let Ok(HGEvent::UserEvent(key_event)) = receiver.recv() {
            ...
        }
    });
}
</code></pre></div></div>

<p>其他剩下的就是业务逻辑，完整的代码可以直接看仓库 <a href="https://github.com/kaixinbaba/hg-tui">https://github.com/kaixinbaba/hg-tui</a></p>

<h2 id="四心路历程">四、心路历程</h2>

<p>一开始我做 <code class="language-plaintext highlighter-rouge">hg-tui</code> 项目的时候，仅仅是为了做个实际的项目把玩一下 <code class="language-plaintext highlighter-rouge">tui.rs</code> 这个框架，做好之后问题层出不穷，但我深知没有与生俱来的完美，只有不断的迭代才能让它越来越好，经过 100 多次的提交后，现在用着感觉顺手多了。<strong>毕竟作者是项目的第一个用户，自己用着不舒服其他人就更不喜欢了！</strong></p>

<p>我想着既然要让别人用，<strong>一定要容易安装</strong>。接着我做了基于 GitHub Action 自动编译和发布，支持 Windows、Linux、macOS <a href="https://github.com/kaixinbaba/hg-tui/releases">直接下载</a>就能用。</p>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531210155137-642531925.png" alt="" /></p>

<p>我还做了对 homebrew 安装的支持，但因为 Star 数不够没有收录到 homecore 要求：30 forks、30 watchers、75 stars</p>

<p><img src="https://img2022.cnblogs.com/blog/759200/202205/759200-20220531210159432-2067459766.png" alt="" /></p>

<p>希望大家看到这里的话能给个 star✨</p>

<blockquote>
  <p>地址：<a href="https://github.com/kaixinbaba/hg-tui">https://github.com/kaixinbaba/hg-tui</a></p>
</blockquote>

<h2 id="五最后">五、最后</h2>

<p><code class="language-plaintext highlighter-rouge">hg-tui</code> 它从出生那一刻起，体内流淌的就是开源的血。</p>

<p>它很小甚至是微不足道，我本不想开源，但<a href="https://github.com/521xueweihan">蛋蛋</a>的一段话让我改变了主意：<strong>开源不是完结，仅仅只是开始</strong>。</p>

<p>一个开源项目可能只是作者的一个灵光乍现，也可能只是为了解决自己实际工作生活中的小小痛点，没准用完就丢到角落里了。但开源出来或许就能找到有相同需求的人，从而延续这个项目的生命，或许这就是开源的本意吧。</p>

<p>以上就是我做这个项目的全部心得和收获，如果你们对 <code class="language-plaintext highlighter-rouge">hg-tui</code> 有什么建议和问题，欢迎给我提 <a href="https://github.com/kaixinbaba/hg-tui/issues">issue</a></p>

<p>最后，如果你喜欢本文和项目的话，欢迎点赞和 Star 爱你们哟～</p>
<blockquote>
  <p>作者:削微寒<br />
原文:https://www.cnblogs.com/xueweihan/p/16333080.html</p>
</blockquote>

  </div><a class="u-url" href="/cnblog/2022/06/01/%E8%A7%A3%E9%94%81%E7%8E%A9%E8%BD%ACHelloGitHub%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">dotnet之美</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">dotnet之美</li><li><a class="u-email" href="mailto:springhgui@outlook.com">springhgui@outlook.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>分享dotnet技术.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
