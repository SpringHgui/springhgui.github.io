<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Django对接支付宝Alipay支付接口 | dotnet之美</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Django对接支付宝Alipay支付接口" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="最新博客更新见我的个人主页: https://xzajyjs.cn 我们在使用Django构建网站时常需要对接第三方支付平台的支付接口，这里就以支付宝为例（其他平台大同小异），使用支付宝开放平台的沙箱环境进行实验。 我们这里使用一个第三方的AliPay Python SDK(github) 下面看一下它的基本使用 调用流程 事实上需要我们网站服务端做的事并不多，只需要生成一个订单向支付宝发出支付请求，等用户支付完毕后向支付宝(通过同步和异步的方式)查询订单、交易信息即可。 在实际生产环境中，需要注意如下各种安全性问题：" />
<meta property="og:description" content="最新博客更新见我的个人主页: https://xzajyjs.cn 我们在使用Django构建网站时常需要对接第三方支付平台的支付接口，这里就以支付宝为例（其他平台大同小异），使用支付宝开放平台的沙箱环境进行实验。 我们这里使用一个第三方的AliPay Python SDK(github) 下面看一下它的基本使用 调用流程 事实上需要我们网站服务端做的事并不多，只需要生成一个订单向支付宝发出支付请求，等用户支付完毕后向支付宝(通过同步和异步的方式)查询订单、交易信息即可。 在实际生产环境中，需要注意如下各种安全性问题：" />
<link rel="canonical" href="/cnblog/2022/05/31/Django%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98%E5%AE%9DAlipay%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3.html" />
<meta property="og:url" content="/cnblog/2022/05/31/Django%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98%E5%AE%9DAlipay%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3.html" />
<meta property="og:site_name" content="dotnet之美" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-31T08:42:22+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Django对接支付宝Alipay支付接口" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-31T08:42:22+00:00","datePublished":"2022-05-31T08:42:22+00:00","description":"最新博客更新见我的个人主页: https://xzajyjs.cn 我们在使用Django构建网站时常需要对接第三方支付平台的支付接口，这里就以支付宝为例（其他平台大同小异），使用支付宝开放平台的沙箱环境进行实验。 我们这里使用一个第三方的AliPay Python SDK(github) 下面看一下它的基本使用 调用流程 事实上需要我们网站服务端做的事并不多，只需要生成一个订单向支付宝发出支付请求，等用户支付完毕后向支付宝(通过同步和异步的方式)查询订单、交易信息即可。 在实际生产环境中，需要注意如下各种安全性问题：","headline":"Django对接支付宝Alipay支付接口","mainEntityOfPage":{"@type":"WebPage","@id":"/cnblog/2022/05/31/Django%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98%E5%AE%9DAlipay%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3.html"},"url":"/cnblog/2022/05/31/Django%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98%E5%AE%9DAlipay%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="dotnet之美" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">dotnet之美</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Django对接支付宝Alipay支付接口</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-05-31T08:42:22+00:00" itemprop="datePublished">May 31, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>最新博客更新见我的个人主页: <a href="https://xzajyjs.cn">https://xzajyjs.cn</a></p>

<p>我们在使用Django构建网站时常需要对接第三方支付平台的支付接口，这里就以支付宝为例（其他平台大同小异），使用支付宝开放平台的沙箱环境进行实验。</p>

<p>我们这里使用一个第三方的<code class="language-plaintext highlighter-rouge">AliPay Python SDK</code>(<a href="https://github.com/fzlee/alipay">github</a>)</p>

<p>下面看一下它的基本使用</p>

<hr />

<h1 id="调用流程">调用流程</h1>

<p><img src="https://serverless-page-bucket-lv779z7b-1307395653.cos.ap-shanghai.myqcloud.com/picgo/202205301102413.png" alt="0ba3e82ad37ecf8649ee4219cfe9d16b" /></p>

<p>事实上需要我们网站服务端做的事并不多，只需要生成一个订单向支付宝发出支付请求，等用户支付完毕后向支付宝(通过同步和异步的方式)查询订单、交易信息即可。</p>

<p>在实际生产环境中，需要注意如下各种安全性问题：</p>

<blockquote>
  <ul>
    <li>由于同步返回的不可靠性，支付结果必须以异步通知或查询接口返回为准，不能依赖同步跳转。</li>
    <li>商户系统接收到异步通知以后，必须通过验签（验证通知中的 sign 参数）来确保支付通知是由支付宝发送的。</li>
    <li>接收到异步通知并验签通过后，请务必核对通知中的 app_id、out_trade_no、total_amount 等参数值是否与请求中的一致，并根据 trade_status 进行后续业务处理。</li>
    <li>在支付宝端，partnerId 与 out_trade_no 唯一对应一笔单据，商户端保证不同次支付 out_trade_no 不可重复；若重复，支付宝会关联到原单据，基本信息一致的情况下会以原单据为准进行支付。</li>
  </ul>
</blockquote>

<hr />

<h1 id="具体实践">具体实践</h1>

<h2 id="1准备工作">1.准备工作</h2>

<p>由于使用真实环境需要商户支付宝账号、上线应用需要审批等流程，我们这里使用支付宝开放平台的<a href="https://open.alipay.com/develop/sandbox/app">沙箱环境</a></p>

<p>沙箱环境中提供了后面需要的参数如<code class="language-plaintext highlighter-rouge">APPID</code>、<code class="language-plaintext highlighter-rouge">APP_PRIVATE_KEY</code>、<code class="language-plaintext highlighter-rouge">ALIPAY_PUBLIC_KEY</code>、<code class="language-plaintext highlighter-rouge">支付宝网关</code>等。</p>

<p>接下来安装<code class="language-plaintext highlighter-rouge">AliPay Python SDK</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 install python-alipay-sdk --upgrade
</code></pre></div></div>

<p>由于是沙箱环境，平台已经提供给我们需要的公钥和私钥，如果是生产环境，则需要通过openssl生成</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl
OpenSSL&gt; genrsa -out app_private_key.pem   2048  # 私钥
OpenSSL&gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥
OpenSSL&gt; exit
</code></pre></div></div>

<p>在支付宝上下载的公钥是一个字符串，你需要在文本的首尾添加标记位：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----BEGIN PUBLIC KEY----- 和 -----END PUBLIC KEY-----
</code></pre></div></div>

<h2 id="2创建订单">2.创建订单</h2>

<p>先在<code class="language-plaintext highlighter-rouge">settings.py</code>中设定一些关键参数</p>

<p><img src="https://serverless-page-bucket-lv779z7b-1307395653.cos.ap-shanghai.myqcloud.com/picgo/202205301130839.png" alt="302882E3-C077-4B1C-8D51-BE26357A2F56" /></p>

<p><img src="https://serverless-page-bucket-lv779z7b-1307395653.cos.ap-shanghai.myqcloud.com/picgo/202205301132200.png" alt="333D5B0A-4B1B-413F-B924-83CD9CB7097C" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 读取公钥和私钥为字符串
app_private_key_string = open("/path/to/your/private/key.pem").read()
alipay_public_key_string = open("/path/to/alipay/public/key.pem").read()
# 沙箱环境提供的APPID
ALIPAY_APP_ID = "2021000120607609"
# 同步回调url（这里需要一个公网ip）
RETURN_URL = "http://xxx.xxx.xxx.xxx/"
# 支付宝网关地址。注意：正式环境和沙箱环境的网关地址不同
GATEWAY = "https://openapi.alipaydev.com/gateway.do?"

from alipay import AliPay, AliPayConfig
from .settings import APP_PRIVATE_KEY, ALIPAY_PUBLIC_KEY, ALIPAY_APP_ID, RETURN_URL, GATEWAY

def create_alipay():
  	# 使用应用公钥进行报文验签
    alipay = AliPay(
        appid=ALIPAY_APP_ID,
        app_notify_url=None,  # 默认异步回调 url
        app_private_key_string=APP_PRIVATE_KEY,
        alipay_public_key_string=ALIPAY_PUBLIC_KEY,
        sign_type="RSA2",
        debug=False,  # 默认 False
        verbose=False,  # 输出调试数据
        config=AliPayConfig(timeout=15)  # 可选，请求超时时间
    )
    return alipay
</code></pre></div></div>

<p>下面可以创建支付订单了(<a href="https://opendocs.alipay.com/open/028r8t?scene=22">官方文档</a>)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 向支付宝提交订单信息
def alipay_pay(subject, total_amount, out_trade_no, return_url_view):
    alipay = create_alipay()	# 先实例化alipay
    return_url = RETURN_URL + return_url_view	# 同步回调url,用于支付完后跳转回网站并对支付状态进行即时检验。这里的return_url_view是用于接收支付宝回调的状态检验的视图函数
    order_string = alipay.api_alipay_trade_page_pay(
        out_trade_no=out_trade_no,	# 商户订单号,这个需要商户自定义
        total_amount=total_amount,	# 支付总金额
        subject=subject,	# 订单标题
        return_url=return_url,	# 同步回调url,用于支付完后跳转回网站并对支付状态进行即时检验
        notify_url="https://example.com/notify"  # 可选，不填则使用默认 notify url
    )
    return order_string		# 返回订单字符串
</code></pre></div></div>

<p>调用</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import string
import random
from .settings import GATEWAY

# 随机生成32位商户交易号
out_trade_no = "".join(random.sample(string.ascii_letters+string.digits, 32))

# 在视图函数对alipay_return进行绑定
# 同步回调url为:  http://xxx.xxx.xxx.xxx/alipay_return
order_string = alipay_pay(subject="测试商品",total_amount=100,out_trade_no=out_trade_no,return_url_view='alipay_return')return HttpResponseRedirect(GATEWAY+order_string)
</code></pre></div></div>

<p><img src="https://serverless-page-bucket-lv779z7b-1307395653.cos.ap-shanghai.myqcloud.com/picgo/202205301149081.png" alt="image-20220530114916011" /></p>

<p>调用后会跳转到支付宝平台，使用沙箱环境提供的买家账号即可完成支付</p>

<p><img src="https://serverless-page-bucket-lv779z7b-1307395653.cos.ap-shanghai.myqcloud.com/picgo/202205301150210.png" alt="image-20220530115037133" /></p>

<p>但是此时我们还不能回调跳转到我们自己的网站，也不能获得订单支付信息，下面还有最后一步。</p>

<h2 id="3同步回调">3.同步回调</h2>

<p>我们刚刚创建的订单信息中填写了<code class="language-plaintext highlighter-rouge">return_url</code>,我们需要一个视图函数来接收，并对其返回值进行分析</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def alipay_return(request):
    processed_dict = {}
    # 回调时alipay会把一些公用信息通过GET方式传参回来，这里用字典去接收存储
    for key, value in request.GET.items():
        processed_dict[key] = value
    """
    processed_dict = {
        'charset': 'utf-8', 
        'out_trade_no': 'xxxxxxx', 	# 这个是我们之前创建订单时生成的商户交易号
        'method': 'alipay.trade.page.pay.return', 
        'total_amount': '100.00', 	# 交易金额
        'trade_no': '20220xxxxxxxx24353', 	# 支付宝交易号
        'auth_app_id': '2021xxxxxx609', 		# 用户appid
        'version': '1.0', 
        'app_id': '2021xxxxxx7609', 		# 沙箱提供的APPID 应用ID
        'sign_type': 'RSA2', 
        'seller_id': '2088xxxxx844', 		# 收款支付宝账号对应的支付宝唯一用户号。
以2088开头的纯16位数字
        'timestamp': '2022-05-28 23:40:55'
    }
    """
    sign = processed_dict.pop("sign", None)

    new_alipay = create_alipay()
    verify_re = new_alipay.verify(processed_dict, sign)
    if verify_re is True:
      print("支付成功")
    else:
      print("支付失败")
</code></pre></div></div>

<blockquote>
  <p>注意：同步回调往往不可靠，因此需要增加一个异步回调检验</p>

  <p>另外，在订单创建后需要向数据库存储订单信息，包括订单金额、商户订单号、appid等，等待回调后与参数校验一致无误后再将订单支付信息进行更新。下面的完整示例不会包括该部分，请自行完成</p>
</blockquote>

<hr />

<h1 id="完整示例">完整示例</h1>

<p>项目结构</p>

<p><img src="https://serverless-page-bucket-lv779z7b-1307395653.cos.ap-shanghai.myqcloud.com/picgo/202205301246810.png" alt="image-20220530124639727" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># alipay.py
from alipay import AliPay, AliPayConfig
from .settings import APP_PRIVATE_KEY, ALIPAY_PUBLIC_KEY, ALIPAY_APP_ID, RETURN_URL

def create_alipay():
    alipay = AliPay(
        appid=ALIPAY_APP_ID,
        app_notify_url=None,  # 默认回调 url
        app_private_key_string=APP_PRIVATE_KEY,
        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
        alipay_public_key_string=ALIPAY_PUBLIC_KEY,
        sign_type="RSA2",  # RSA 或者 RSA2
        debug=False,  # 默认 False
        verbose=False,  # 输出调试数据
        config=AliPayConfig(timeout=15)  # 可选，请求超时时间
    )
    return alipay

def alipay_pay(subject, total_amount, out_trade_no, return_url_view):
    alipay = create_alipay()
    return_url = RETURN_URL + return_url_view
    order_string = alipay.api_alipay_trade_page_pay(
        out_trade_no=out_trade_no,
        total_amount=total_amount,
        subject=subject,
        return_url=return_url,
        notify_url="https://example.com/notify"  # 可选，不填则使用默认 notify url
    )
    return order_string

# settings.py
...
...

ALIPAY_APP_ID = "xxxxxx"
APP_PRIVATE_KEY = open(os.path.join(BASE_DIR, 'alipay/app_private_key.pem'), 'r').read()
ALIPAY_PUBLIC_KEY = open(os.path.join(BASE_DIR, 'alipay/alipay_public_key.pem'), 'r').read()
RETURN_URL = "http://xxxxxx/"
GATEWAY = "https://openapi.alipaydev.com/gateway.do?"

# urls.py
from django.contrib import admin
from django.urls import path
from . import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.index),
    path('alipay_return/', views.alipay_return)
]

# views.py
import random
import string
from django.http import HttpResponseRedirect
from django.shortcuts import render
from ali_django.alipay import alipay_pay, create_alipay
from django.conf import settings

def index(request):
    if request.method == "GET":
        return render(request, 'index.html')
    elif request.method == "POST":
        # 随机生成32位商户交易号
        out_trade_no = "".join(random.sample(string.ascii_letters + string.digits, 32))

        order_string = alipay_pay(subject="测试商品", total_amount=100, out_trade_no=out_trade_no,return_url_view='alipay_return')
        return HttpResponseRedirect(settings.GATEWAY + order_string)

def alipay_return(request):
    processed_dict = {}
    # 回调时alipay会把一些公用信息通过GET方式传参回来，这里用字典去接收存储
    for key, value in request.GET.items():
        processed_dict[key] = value
    sign = processed_dict.pop("sign", None)

    new_alipay = create_alipay()
    verify_re = new_alipay.verify(processed_dict, sign)
    if verify_re is True:
        print("支付成功")
    else:
        print("支付失败")

&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;支付宝支付接口测试&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="" method="post"&gt;
    &lt;input type="submit" value="提交"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt; &gt; 作者:xzajyjs   &gt; 原文:https://www.cnblogs.com/xzajyjs/p/16326410.html  
</code></pre></div></div>

  </div><a class="u-url" href="/cnblog/2022/05/31/Django%E5%AF%B9%E6%8E%A5%E6%94%AF%E4%BB%98%E5%AE%9DAlipay%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">dotnet之美</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">dotnet之美</li><li><a class="u-email" href="mailto:springhgui@outlook.com">springhgui@outlook.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>分享dotnet技术.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
