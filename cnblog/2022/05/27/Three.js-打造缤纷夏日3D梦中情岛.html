<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Three.js 打造缤纷夏日3D梦中情岛 🌊 | dotnet之美</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Three.js 打造缤纷夏日3D梦中情岛 🌊" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="声明：本文涉及图文和模型素材仅用于个人学习、研究和欣赏，请勿二次修改、非法传播、转载、出版、商用、及进行其他获利行为。" />
<meta property="og:description" content="声明：本文涉及图文和模型素材仅用于个人学习、研究和欣赏，请勿二次修改、非法传播、转载、出版、商用、及进行其他获利行为。" />
<link rel="canonical" href="/cnblog/2022/05/27/Three.js-%E6%89%93%E9%80%A0%E7%BC%A4%E7%BA%B7%E5%A4%8F%E6%97%A53D%E6%A2%A6%E4%B8%AD%E6%83%85%E5%B2%9B.html" />
<meta property="og:url" content="/cnblog/2022/05/27/Three.js-%E6%89%93%E9%80%A0%E7%BC%A4%E7%BA%B7%E5%A4%8F%E6%97%A53D%E6%A2%A6%E4%B8%AD%E6%83%85%E5%B2%9B.html" />
<meta property="og:site_name" content="dotnet之美" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-27T08:36:30+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Three.js 打造缤纷夏日3D梦中情岛 🌊" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-27T08:36:30+00:00","datePublished":"2022-05-27T08:36:30+00:00","description":"声明：本文涉及图文和模型素材仅用于个人学习、研究和欣赏，请勿二次修改、非法传播、转载、出版、商用、及进行其他获利行为。","headline":"Three.js 打造缤纷夏日3D梦中情岛 🌊","mainEntityOfPage":{"@type":"WebPage","@id":"/cnblog/2022/05/27/Three.js-%E6%89%93%E9%80%A0%E7%BC%A4%E7%BA%B7%E5%A4%8F%E6%97%A53D%E6%A2%A6%E4%B8%AD%E6%83%85%E5%B2%9B.html"},"url":"/cnblog/2022/05/27/Three.js-%E6%89%93%E9%80%A0%E7%BC%A4%E7%BA%B7%E5%A4%8F%E6%97%A53D%E6%A2%A6%E4%B8%AD%E6%83%85%E5%B2%9B.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="dotnet之美" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">dotnet之美</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Three.js 打造缤纷夏日3D梦中情岛 🌊</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-05-27T08:36:30+00:00" itemprop="datePublished">May 27, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>声明：本文涉及图文和模型素材仅用于个人学习、研究和欣赏，请勿二次修改、非法传播、转载、出版、商用、及进行其他获利行为。</p>
</blockquote>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084420708-1192650956.gif" alt="" /></p>

<h2 id="背景">背景</h2>

<p>深居内陆的人们，大概每个人都有过大海之梦吧。夏日傍晚在沙滩漫步奔跑；或是在海上冲浪游泳；或是在海岛游玩探险；亦或静待日出日落……本文使用 <code class="language-plaintext highlighter-rouge">React + Three.js</code> 技术栈，实现 <code class="language-plaintext highlighter-rouge">3D</code> 海洋和岛屿，主要包含知识点包括：<code class="language-plaintext highlighter-rouge">Tone Mapping</code>、<code class="language-plaintext highlighter-rouge">Water</code> 类、<code class="language-plaintext highlighter-rouge">Sky</code> 类、<code class="language-plaintext highlighter-rouge">Shader</code> 着色、<code class="language-plaintext highlighter-rouge">ShaderMaterial</code> 着色器材质、<code class="language-plaintext highlighter-rouge">Raycaster</code> 检测遮挡以及 <code class="language-plaintext highlighter-rouge">Three.js</code> 的其他基础知识，让我们在这个夏天通过此页面共赴大海之约。</p>

<h2 id="效果">效果</h2>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084442410-1141227374.png" alt="" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">💻</code> 本页面仅适配 <code class="language-plaintext highlighter-rouge">PC</code> 端，大屏访问效果更佳。</li>
  <li><code class="language-plaintext highlighter-rouge">👁‍🗨</code> 在线预览地址1：<a href="https://3d-eosin.vercel.app/#/ocean">https://3d-eosin.vercel.app/#/ocean</a></li>
  <li><code class="language-plaintext highlighter-rouge">👁‍🗨</code> 在线预览地址2：<a href="https://dragonir.github.io/3d/#/ocean">https://dragonir.github.io/3d/#/ocean</a></li>
</ul>

<h2 id="实现">实现</h2>

<h3 id="-素材准备">👨‍🎨 素材准备</h3>

<p>开发之前，需要准备页面所需的素材，本文用到的海岛素材是在 <a href="https://sketchfab.com/feed">sketchfab.com</a> 找的免费模型。下载好素材之后，在 <code class="language-plaintext highlighter-rouge">Blender</code> 中打开，按自己的想法调整模型的颜色、材质、大小比例、角度、位置等信息，删减不需要的模块、缩减面数以压缩模型体积，最后删除相机、光照、<code class="language-plaintext highlighter-rouge">UV</code>、动画等多余信息，<strong>只导出模型网格</strong>备用。</p>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084454778-35559124.png" alt="" /></p>

<h3 id="-资源引入">📦 资源引入</h3>

<p>首先，引入开发所需的必备资源，<code class="language-plaintext highlighter-rouge">OrbitControls</code> 用于镜头轨道控制；<code class="language-plaintext highlighter-rouge">GLTFLoader</code> 用于加载 <code class="language-plaintext highlighter-rouge">gltf</code> 格式模型；<code class="language-plaintext highlighter-rouge">Water</code> 是 <code class="language-plaintext highlighter-rouge">Three.js</code> 内置的一个类，可以生成类似水的效果；<code class="language-plaintext highlighter-rouge">Sky</code> 可以生成天空效果；<code class="language-plaintext highlighter-rouge">TWEEN</code> 用来生成补间动画；<code class="language-plaintext highlighter-rouge">Animations</code> 是对 <code class="language-plaintext highlighter-rouge">TWEEN</code> 控制镜头补间动画方法的封装；<code class="language-plaintext highlighter-rouge">waterTexture</code> 、<code class="language-plaintext highlighter-rouge">flamingoModel</code>、<code class="language-plaintext highlighter-rouge">islandModel</code> 三者分别是水的法向贴图、飞鸟模型、海岛模型；<code class="language-plaintext highlighter-rouge">vertexShader</code> 和 <code class="language-plaintext highlighter-rouge">fragmentShader</code> 是用于生成彩虹的 <code class="language-plaintext highlighter-rouge">Shader</code> 着色器。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { Water } from 'three/examples/jsm/objects/Water';
import { Sky } from 'three/examples/jsm/objects/Sky';
import { TWEEN } from "three/examples/jsm/libs/tween.module.min";
import Animations from '@/assets/utils/animations';
import waterTexture from '@/containers/Ocean/images/waternormals.jpg';
import islandModel from '@/containers/Ocean/models/island.glb';
import flamingoModel from '@/containers/Ocean/models/flamingo.glb';
import vertexShader from '@/containers/Ocean/shaders/rainbow/vertex.glsl';
import fragmentShader from '@/containers/Ocean/shaders/rainbow/fragment.glsl';
</code></pre></div></div>

<h3 id="-页面结构">📃 页面结构</h3>

<p>页面主要由3部分构成：<code class="language-plaintext highlighter-rouge">canvas.webgl</code> 用于渲染 <code class="language-plaintext highlighter-rouge">WEBGL</code> 场景；<code class="language-plaintext highlighter-rouge">div.loading</code> 用于模型加载完成前显示加载进度；<code class="language-plaintext highlighter-rouge">div.point</code> 用于添加交互点，省略部分是其他几个交互点信息。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>render () {
  return (
    &lt;div className='ocean'&gt;
      &lt;canvas className='webgl'&gt;&lt;/canvas&gt;
      {this.state.loadingProcess === 100 ? '' : (
        &lt;div className='loading'&gt;
          &lt;span className='progress'&gt;{this.state.loadingProcess} %&lt;/span&gt;
        &lt;/div&gt;
      )}
      &lt;div className="point point-0"&gt;
        &lt;div className="label label-0"&gt;1&lt;/div&gt;
        &lt;div className="text"&gt;灯塔：矗立在海岸的岩石之上，白色的塔身以及红色的塔屋，在湛蓝色的天空和深蓝色大海的映衬下，显得如此醒目和美丽。&lt;/div&gt;
      &lt;/div&gt;
      // ...
    &lt;/div&gt;
  )
}
</code></pre></div></div>

<h3 id="-场景初始化">🌏 场景初始化</h3>

<p>在这部分，先定义好需要的状态值，<code class="language-plaintext highlighter-rouge">loadingProcess</code> 用于显示页面加载进度。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>state = {
  loadingProcess: 0
}
</code></pre></div></div>

<p>定义一些全局变量和参数，初始化场景、相机、镜头轨道控制器、灯光、页面缩放监听等。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const clock = new THREE.Clock();
const raycaster = new THREE.Raycaster()
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight
}
const renderer = new THREE.WebGLRenderer({
  canvas: document.querySelector('canvas.webgl'),
  antialias: true
});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
renderer.setSize(sizes.width, sizes.height);
// 设置渲染效果
renderer.toneMapping = THREE.ACESFilmicToneMapping;
// 创建场景
const scene = new THREE.Scene();
// 创建相机
const camera = new THREE.PerspectiveCamera(55, sizes.width / sizes.height, 1, 20000);
camera.position.set(0, 600, 1600);
// 添加镜头轨道控制器
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 0, 0);
controls.enableDamping = true;
controls.enablePan = false;
controls.maxPolarAngle = 1.5;
controls.minDistance = 50;
controls.maxDistance = 1200;
// 添加环境光
const ambientLight = new THREE.AmbientLight(0xffffff, .8);
scene.add(ambientLight);
// 添加平行光
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.color.setHSL(.1, 1, .95);
dirLight.position.set(-1, 1.75, 1);
dirLight.position.multiplyScalar(30);
scene.add(dirLight);
// 页面缩放监听并重新更新场景和相机
window.addEventListener('resize', () =&gt; {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}, false);
</code></pre></div></div>

<h4 id="-tone-mapping"><code class="language-plaintext highlighter-rouge">💡</code> Tone Mapping</h4>

<p>可以注意到，本文使用了 <code class="language-plaintext highlighter-rouge">renderer.toneMapping = THREE.ACESFilmicToneMapping</code> 来设置页面渲染效果。目前 <code class="language-plaintext highlighter-rouge">Three.js</code> 中有以下几种 <code class="language-plaintext highlighter-rouge">Tone Mapping</code> 值，它们定义了 <code class="language-plaintext highlighter-rouge">WebGLRenderer</code> 的 <code class="language-plaintext highlighter-rouge">toneMapping</code> 属性，用于在近似标准计算机显示器或移动设备的低动态范围 <code class="language-plaintext highlighter-rouge">LDR</code> 屏幕上展示高动态范围 <code class="language-plaintext highlighter-rouge">HDR</code> 外观。大家可以修改不同的值看看渲染效果有何不同。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">THREE.NoToneMapping</code></li>
  <li><code class="language-plaintext highlighter-rouge">THREE.LinearToneMapping</code></li>
  <li><code class="language-plaintext highlighter-rouge">THREE.ReinhardToneMapping</code></li>
  <li><code class="language-plaintext highlighter-rouge">THREE.CineonToneMapping</code></li>
  <li><code class="language-plaintext highlighter-rouge">THREE.ACESFilmicToneMapping</code></li>
</ul>

<h3 id="-海">🌊 海</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">Three.js</code> 自带的 <code class="language-plaintext highlighter-rouge">Water</code> 类创建海洋，首先创建一个平面网格 <code class="language-plaintext highlighter-rouge">waterGeometry</code>，让后将它传递给 <code class="language-plaintext highlighter-rouge">Water</code>，并配置相关属性，最后将海洋添加到场景中。</p>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084516951-1880876264.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
const water = new Water(waterGeometry, {
  textureWidth: 512,
  textureHeight: 512,
  waterNormals: new THREE.TextureLoader().load(waterTexture,  texture =&gt; {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
  }),
  sunDirection: new THREE.Vector3(),
  sunColor: 0xffffff,
  waterColor: 0x0072ff,
  distortionScale: 4,
  fog: scene.fog !== undefined
});
water.rotation.x = - Math.PI / 2;
scene.add(water);
</code></pre></div></div>

<h4 id="-water-类"><code class="language-plaintext highlighter-rouge">💡</code> Water 类</h4>

<p><strong>参数说明</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">textureWidth</code>：画布宽度</li>
  <li><code class="language-plaintext highlighter-rouge">textureHeight</code>：画布高度</li>
  <li><code class="language-plaintext highlighter-rouge">waterNormals</code>：法向量贴图</li>
  <li><code class="language-plaintext highlighter-rouge">sunDirection</code>：阳光方向</li>
  <li><code class="language-plaintext highlighter-rouge">sunColor</code>：阳光颜色</li>
  <li><code class="language-plaintext highlighter-rouge">waterColor</code>：水颜色</li>
  <li><code class="language-plaintext highlighter-rouge">distortionScale</code>：物体倒影分散度</li>
  <li><code class="language-plaintext highlighter-rouge">fog</code>：雾</li>
  <li><code class="language-plaintext highlighter-rouge">alpha</code>：透明度</li>
</ul>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084538354-90419473.gif" alt="" /></p>

<h3 id="-空">🌞 空</h3>

<p>接着，使用 <code class="language-plaintext highlighter-rouge">Three.js</code> 自带的天空类 <code class="language-plaintext highlighter-rouge">Sky</code> 创建天空，通过修改着色器参数设置天空样式，然后创建太阳并添加到场景中。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const sky = new Sky();
sky.scale.setScalar(10000);
scene.add(sky);
const skyUniforms = sky.material.uniforms;
skyUniforms['turbidity'].value = 20;
skyUniforms['rayleigh'].value = 2;
skyUniforms['mieCoefficient'].value = 0.005;
skyUniforms['mieDirectionalG'].value = 0.8;
// 太阳
const sun = new THREE.Vector3();
const pmremGenerator = new THREE.PMREMGenerator(renderer);
const phi = THREE.MathUtils.degToRad(88);
const theta = THREE.MathUtils.degToRad(180);
sun.setFromSphericalCoords(1, phi, theta);
sky.material.uniforms['sunPosition'].value.copy(sun);
water.material.uniforms['sunDirection'].value.copy(sun).normalize();
scene.environment = pmremGenerator.fromScene(sky).texture;
</code></pre></div></div>

<h4 id="-sky-类"><code class="language-plaintext highlighter-rouge">💡</code> Sky 类</h4>

<p><strong>天空材质着色器参数说明</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">turbidity</code> 浑浊度</li>
  <li><code class="language-plaintext highlighter-rouge">rayleigh</code> 视觉效果就是傍晚晚霞的红光的深度</li>
  <li><code class="language-plaintext highlighter-rouge">luminance</code> 视觉效果整体提亮或变暗</li>
  <li><code class="language-plaintext highlighter-rouge">mieCoefficient</code> 散射系数</li>
  <li><code class="language-plaintext highlighter-rouge">mieDirectionalG</code> 定向散射值</li>
</ul>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084559915-1147282276.gif" alt="" /></p>

<h3 id="-虹">🌈 虹</h3>

<p>首先，创建具有彩虹渐变效果的着色器 <code class="language-plaintext highlighter-rouge">Shader</code>, 然后使用着色器材质 <code class="language-plaintext highlighter-rouge">ShaderMaterial</code>， 创建圆环 <code class="language-plaintext highlighter-rouge">THREE.TorusGeometry</code> 并添加到场景中。</p>

<p><strong>顶点着色器 vertex.glsl</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>varying vec2 vUV;
varying vec3 vNormal;
void main () {
  vUV = uv;
  vNormal = vec3(normal);
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</code></pre></div></div>

<p><strong>片段着色器 fragment.glsl</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>varying vec2 vUV;
varying vec3 vNormal;
void main () {
  vec4 c = vec4(abs(vNormal) + vec3(vUV, 0.0), 0.1); // 设置透明度为0.1
  gl_FragColor = c;
}
</code></pre></div></div>

<p><strong>彩虹渐变着色器效果</strong>：</p>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084614968-974971802.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const material = new THREE.ShaderMaterial({
  side: THREE.DoubleSide,
  transparent: true,
  uniforms: {},
  vertexShader: vertexShader,
  fragmentShader: fragmentShader
});
const geometry = new THREE.TorusGeometry(200, 10, 50, 100);
const torus = new THREE.Mesh(geometry, material);
torus.opacity = .1;
torus.position.set(0, -50, -400);
scene.add(torus);
</code></pre></div></div>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084626147-524969696.png" alt="" /></p>

<h4 id="-shader-着色器"><code class="language-plaintext highlighter-rouge">💡</code> Shader 着色器</h4>

<p><code class="language-plaintext highlighter-rouge">WebGL</code> 中记述了坐标变换的机制就叫做着色器 <code class="language-plaintext highlighter-rouge">Shader</code>，着色器又有处理几何图形顶点的 <code class="language-plaintext highlighter-rouge">顶点着色器</code> 和处理像素的 <code class="language-plaintext highlighter-rouge">片段着色器</code> 两种类型</p>

<h5 id="准备顶点着色器和片元着色器">准备顶点着色器和片元着色器</h5>

<p>着色器的添加有多种方法，最简单的方法就是把着色器记录在 <code class="language-plaintext highlighter-rouge">HTML</code> 中。该方法利用<code class="language-plaintext highlighter-rouge">HTML</code> 的 <code class="language-plaintext highlighter-rouge">script</code> 标签来实现，如：</p>

<p><strong>顶点着色器</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script id="vshader" type="x-shader/x-vertex"&gt;&lt;/script&gt;
</code></pre></div></div>

<p><strong>片段着色器</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script id="fshader" type="x-shader/x-fragment"&gt;&lt;/script&gt;
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">🎏</code> 也可以像本文中一样，直接使用单独创建 <code class="language-plaintext highlighter-rouge">glsl</code> 格式文件引入。</p>
</blockquote>

<h5 id="着色器的三个变量与运行方式">着色器的三个变量与运行方式</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Uniforms</code>：是所有顶点都具有相同的值的变量。 比如灯光，雾，和阴影贴图就是被储存在 <code class="language-plaintext highlighter-rouge">uniforms</code> 中的数据。<code class="language-plaintext highlighter-rouge">uniforms</code> 可以通过顶点着色器和片元着色器来访问。</li>
  <li><code class="language-plaintext highlighter-rouge">Attributes</code>：是与每个顶点关联的变量。例如，顶点位置，法线和顶点颜色都是存储在 <code class="language-plaintext highlighter-rouge">attributes</code> 中的数据。<code class="language-plaintext highlighter-rouge">attributes</code> 只可以在顶点着色器中访问。</li>
  <li><code class="language-plaintext highlighter-rouge">Varyings</code>：是从顶点着色器传递到片元着色器的变量。对于每一个片元，每一个<code class="language-plaintext highlighter-rouge">varying</code> 的值将是相邻顶点值的平滑插值。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">顶点着色器</code> 首先运行，它接收 <code class="language-plaintext highlighter-rouge">attributes</code>， 计算每个单独顶点的位置，并将其他数据<code class="language-plaintext highlighter-rouge">varyings</code> 传递给片段着色器。<code class="language-plaintext highlighter-rouge">片段着色器</code> 后运行，它设置渲染到屏幕的每个单独的片段的颜色。</p>

<h4 id="-shadermaterial-着色器材质"><code class="language-plaintext highlighter-rouge">💡</code> ShaderMaterial 着色器材质</h4>

<p><code class="language-plaintext highlighter-rouge">Three.js</code> 所谓的材质对象 <code class="language-plaintext highlighter-rouge">Material</code> 本质上就是着色器代码和需要传递的 <code class="language-plaintext highlighter-rouge">uniform</code> 数据<strong>光源、颜色、矩阵</strong>。<code class="language-plaintext highlighter-rouge">Three.js</code> 提供可直接渲染着色器语法的材质 <code class="language-plaintext highlighter-rouge">ShaderMaterial</code> 和 <code class="language-plaintext highlighter-rouge">RawShaderMaterial</code>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RawShaderMaterial</code>: 和原生 <code class="language-plaintext highlighter-rouge">WebGL</code> 中一样，顶点着色器、片元着色器代码基本没有任何区别，不过顶点数据和 <code class="language-plaintext highlighter-rouge">uniform</code> 数据可以通过 <code class="language-plaintext highlighter-rouge">Three.js</code> 的 <code class="language-plaintext highlighter-rouge">API</code> 快速传递，要比使用 <code class="language-plaintext highlighter-rouge">WebGL</code> 原生的 <code class="language-plaintext highlighter-rouge">API</code> 与着色器变量绑定要方便得多。</li>
  <li><code class="language-plaintext highlighter-rouge">ShaderMaterial</code>：<code class="language-plaintext highlighter-rouge">ShaderMaterial</code> 比 <code class="language-plaintext highlighter-rouge">RawShaderMaterial</code> 更方便些，着色器中的很多变量不用声明，<code class="language-plaintext highlighter-rouge">Three.js</code> 系统会自动设置，比如顶点坐标变量、投影矩阵、视图矩阵等。</li>
</ul>

<p><strong>构造函数</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ShaderMaterial(parameters : Object)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">parameters</code>：可选，用于定义材质外观的对象，具有一个或多个属性。</p>

<p><strong>常用属性</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">attributes[Object]</code>：接受如下形式的对象，<code class="language-plaintext highlighter-rouge">{ attribute1: { value: []} }</code> 指定要传递给顶点着色器代码的 <code class="language-plaintext highlighter-rouge">attributes</code>；键为 <code class="language-plaintext highlighter-rouge">attribute</code> 修饰变量的名称，值也是对象格式，如 <code class="language-plaintext highlighter-rouge">{ value: [] }</code>， <code class="language-plaintext highlighter-rouge">value</code> 是固定名称，因为 <code class="language-plaintext highlighter-rouge">attribute</code> 相对于所有顶点，所以应该回传一个数组格式。只有 <code class="language-plaintext highlighter-rouge">bufferGeometry</code> 类型的能使用该属性。</li>
  <li><code class="language-plaintext highlighter-rouge">.uniforms[Object]</code>：如下形式的对象：<code class="language-plaintext highlighter-rouge">{ uniform1: { value: 1.0 }, uniform2: { value: 2.0 }}</code> 指定要传递给<code class="language-plaintext highlighter-rouge">shader</code> 代码的 <code class="language-plaintext highlighter-rouge">uniforms</code>；键为 <code class="language-plaintext highlighter-rouge">uniform</code> 的名称，值是如下形式：<code class="language-plaintext highlighter-rouge">{ value: 1.0 }</code> 这里 <code class="language-plaintext highlighter-rouge">value</code> 是 <code class="language-plaintext highlighter-rouge">uniform</code> 的值。名称必须匹配着色器代码中  <code class="language-plaintext highlighter-rouge">uniform</code> 的 <code class="language-plaintext highlighter-rouge">name</code>，和 <code class="language-plaintext highlighter-rouge">GLSL</code> 代码中的定义一样。 注意，<code class="language-plaintext highlighter-rouge">uniforms</code> 逐帧被刷新，所以更新 <code class="language-plaintext highlighter-rouge">uniform</code> 值将立即更新 <code class="language-plaintext highlighter-rouge">GLSL</code> 代码中的相应值。</li>
  <li><code class="language-plaintext highlighter-rouge">.fragmentShader[String]</code>：片元着色器的 <code class="language-plaintext highlighter-rouge">GLSL</code> 代码，它也可以作为一个字符串直接传递或者通过 <code class="language-plaintext highlighter-rouge">AJAX</code> 加载。</li>
  <li><code class="language-plaintext highlighter-rouge">.vertexShader[String]</code>：顶点着色器的 <code class="language-plaintext highlighter-rouge">GLSL</code> 代码，它也可以作为一个字符串直接传递或者通过 <code class="language-plaintext highlighter-rouge">AJAX</code> 加载。</li>
</ul>

<h3 id="-岛">🌴 岛</h3>

<p>接着，使用 <code class="language-plaintext highlighter-rouge">GLTFLoader</code> 加载岛屿模型并添加到场景中。加载之前可以使用 <code class="language-plaintext highlighter-rouge">LoadingManager</code> 来管理加载进度。</p>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084647633-673151842.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const manager = new THREE.LoadingManager();
manager.onProgress = async(url, loaded, total) =&gt; {
  if (Math.floor(loaded / total * 100) === 100) {
    this.setState({ loadingProcess: Math.floor(loaded / total * 100) });
    Animations.animateCamera(camera, controls, { x: 0, y: 40, z: 140 }, { x: 0, y: 0, z: 0 }, 4000, () =&gt; {
      this.setState({ sceneReady: true });
    });
  } else {
    this.setState({ loadingProcess: Math.floor(loaded / total * 100) });
  }
};
const loader = new GLTFLoader(manager);
loader.load(islandModel, mesh =&gt; {
  mesh.scene.traverse(child =&gt; {
    if (child.isMesh) {
      child.material.metalness = .4;
      child.material.roughness = .6;
    }
  })
  mesh.scene.position.set(0, -2, 0);
  mesh.scene.scale.set(33, 33, 33);
  scene.add(mesh.scene);
});
</code></pre></div></div>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084700152-531897880.png" alt="" /></p>

<h3 id="-鸟">🦅 鸟</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">GLTFLoader</code> 加载岛屿模型添加到场景中，获取模型自带的动画帧并进行播放，记得要在 <code class="language-plaintext highlighter-rouge">requestAnimationFrame</code> 中更新动画。可以使用 <code class="language-plaintext highlighter-rouge">clone</code> 方法在场景中添加多只飞鸟。鸟模型来源于 <code class="language-plaintext highlighter-rouge">Three.js</code> 官网。</p>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084713125-1891687102.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loader.load(flamingoModel, gltf =&gt; {
  const mesh = gltf.scene.children[0];
  mesh.scale.set(.35, .35, .35);
  mesh.position.set(-100, 80, -300);
  mesh.rotation.y = - 1;
  mesh.castShadow = true;
  scene.add(mesh);
  const mixer = new THREE.AnimationMixer(mesh);
  mixer.clipAction(gltf.animations[0]).setDuration(1.2).play();
  this.mixers.push(mixer);
});
</code></pre></div></div>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084839955-1522409821.png" alt="" /></p>

<h3 id="-交互点">🖐 交互点</h3>

<p>添加交互点，鼠标 <code class="language-plaintext highlighter-rouge">hover</code> 悬浮时显示提示语，点击交互点可以切换镜头角度，视角聚焦到交互点对应的位置 <code class="language-plaintext highlighter-rouge">📍</code> 上。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const points = [
  {
    position: new THREE.Vector3(10, 46, 0),
    element: document.querySelector('.point-0')
  },
  // ...
];
document.querySelectorAll('.point').forEach(item =&gt; {
  item.addEventListener('click', event =&gt; {
    let className = event.target.classList[event.target.classList.length - 1];
    switch(className) {
      case 'label-0':
        Animations.animateCamera(camera, controls, { x: -15, y: 80, z: 60 }, { x: 0, y: 0, z: 0 }, 1600, () =&gt; {});
        break;
      // ...
    }
  }, false);
});
</code></pre></div></div>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084853134-1885724838.png" alt="" /></p>

<h3 id="-动画">🎥 动画</h3>

<p>在 <code class="language-plaintext highlighter-rouge">requestAnimationFrame</code> 中更新水、镜头轨道控制器、相机、<code class="language-plaintext highlighter-rouge">TWEEN</code>、交互点等动画。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const animate = () =&gt; {
  requestAnimationFrame(animate);
  water.material.uniforms['time'].value += 1.0 / 60.0;
  controls &amp;&amp; controls.update();
  const delta = clock.getDelta();
  this.mixers &amp;&amp; this.mixers.forEach(item =&gt; {
    item.update(delta);
  });
  const timer = Date.now() * 0.0005;
  TWEEN &amp;&amp; TWEEN.update();
  camera &amp;&amp; (camera.position.y += Math.sin(timer) * .05);
  if (this.state.sceneReady) {
    // 遍历每个点
    for (const point of points) {
      // 获取2D屏幕位置
      const screenPosition = point.position.clone();
      screenPosition.project(camera);
      raycaster.setFromCamera(screenPosition, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      if (intersects.length === 0) {
        // 未找到相交点，显示
        point.element.classList.add('visible');
      } else {
        // 找到相交点
        // 获取相交点的距离和点的距离
        const intersectionDistance = intersects[0].distance;
        const pointDistance = point.position.distanceTo(camera.position);
        // 相交点距离比点距离近，隐藏；相交点距离比点距离远，显示
        intersectionDistance &lt; pointDistance ? point.element.classList.remove('visible') :  point.element.classList.add('visible');
      }
      const translateX = screenPosition.x * sizes.width * 0.5;
      const translateY = - screenPosition.y * sizes.height * 0.5;
      point.element.style.transform = `translateX(${translateX}px) translateY(${translateY}px)`;
    }
  }
  renderer.render(scene, camera);
}
animate();
}
</code></pre></div></div>

<h4 id="-raycaster-检测遮挡"><code class="language-plaintext highlighter-rouge">💡</code> Raycaster 检测遮挡</h4>

<p>仔细观察，在上述 <code class="language-plaintext highlighter-rouge">👆</code> 更新交互点动画的方法中，通过 <code class="language-plaintext highlighter-rouge">raycaster</code> 射线来检查交互点是否被物体遮挡，如果被遮挡就隐藏交互点，否则显示交互点，大家可以通过旋转场景观察到这一效果。</p>

<p><img src="https://img2022.cnblogs.com/blog/772544/202205/772544-20220527084909950-1697050434.gif" alt="" /></p>

<h2 id="总结">总结</h2>

<p>本文包含的新知识点主要包括：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Tone Mapping</code></li>
  <li><code class="language-plaintext highlighter-rouge">Water</code> 类</li>
  <li><code class="language-plaintext highlighter-rouge">Sky</code> 类</li>
  <li><code class="language-plaintext highlighter-rouge">Shader</code> 着色器</li>
  <li><code class="language-plaintext highlighter-rouge">ShaderMaterial</code> 着色器材质</li>
  <li><code class="language-plaintext highlighter-rouge">Raycaster</code> 检测遮挡</li>
</ul>

<blockquote>
  <p>想了解其他前端知识或其他未在本文中详细描述的 <code class="language-plaintext highlighter-rouge">Web 3D</code> 开发技术相关知识，可阅读我往期的文章。<strong>转载请注明原文地址和作者</strong>。如果觉得文章对你有帮助，不要忘了<strong>一键三连哦 👍</strong>。</p>
</blockquote>

<h2 id="参考">参考</h2>

<ul>
  <li>[1]. <a href="https://threejs.org">https://threejs.org</a></li>
</ul>

<h2 id="附录">附录</h2>

<ul>
  <li><a href="https://juejin.cn/column/7049923956257587213">朕的3D专栏</a></li>
  <li>[1]. <a href="https://juejin.cn/post/7081429595689320478">🦊 Three.js 实现3D开放世界小游戏：阿狸的多元宇宙</a></li>
  <li>[2]. <a href="https://juejin.cn/post/7077726955528781832">🔥 Three.js 火焰效果实现艾尔登法环动态logo</a></li>
  <li>[3]. <a href="https://juejin.cn/post/7060292943608807460">🐼 Three.js 实现2022冬奥主题3D趣味页面，含冰墩墩</a></li>
  <li><code class="language-plaintext highlighter-rouge">...</code></li>
  <li>[1]. <a href="https://juejin.cn/post/7018722520345870350">📷 前端实现很哇塞的浏览器端扫码功能</a></li>
  <li>[2]. <a href="https://juejin.cn/post/7007432493569671182">🌏 前端瓦片地图加载之塞尔达传说旷野之息</a></li>
  <li>[3]. <a href="https://juejin.cn/post/6972759988632551460">😱 仅用CSS几步实现赛博朋克2077风格视觉效果</a></li>
  <li><code class="language-plaintext highlighter-rouge">...</code></li>
</ul>

<blockquote>
  <p>本文作者：dragonir  本文地址：<a href="https://www.cnblogs.com/dragonir/p/16316217.html">https://www.cnblogs.com/dragonir/p/16316217.html</a>
作者:Dragonir
原文:https://www.cnblogs.com/dragonir/p/16316217.html</p>
</blockquote>

  </div><a class="u-url" href="/cnblog/2022/05/27/Three.js-%E6%89%93%E9%80%A0%E7%BC%A4%E7%BA%B7%E5%A4%8F%E6%97%A53D%E6%A2%A6%E4%B8%AD%E6%83%85%E5%B2%9B.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">dotnet之美</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">dotnet之美</li><li><a class="u-email" href="mailto:springhgui@outlook.com">springhgui@outlook.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>分享dotnet技术.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
