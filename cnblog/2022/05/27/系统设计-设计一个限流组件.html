<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>【系统设计】设计一个限流组件 | dotnet之美</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="【系统设计】设计一个限流组件" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="限速器 (Rate Limiter) 相信大家都不会陌生，在网络系统中，限速器可以控制客户端发送流量的速度，比如 TCP, QUIC 等协议。而在 HTTP 的世界中， 限速器可以限制客户端在一段时间内发送请求的次数，如果超过设定的阈值，多余的请求就会被丢弃。 生活中也有很多这样的例子，比如 用户一分钟最多能发 5 条微博 用户一天最多能投 3 次票 用户一小时登录超过5次后，需要等待一段时间才能重试。" />
<meta property="og:description" content="限速器 (Rate Limiter) 相信大家都不会陌生，在网络系统中，限速器可以控制客户端发送流量的速度，比如 TCP, QUIC 等协议。而在 HTTP 的世界中， 限速器可以限制客户端在一段时间内发送请求的次数，如果超过设定的阈值，多余的请求就会被丢弃。 生活中也有很多这样的例子，比如 用户一分钟最多能发 5 条微博 用户一天最多能投 3 次票 用户一小时登录超过5次后，需要等待一段时间才能重试。" />
<link rel="canonical" href="/cnblog/2022/05/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6.html" />
<meta property="og:url" content="/cnblog/2022/05/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6.html" />
<meta property="og:site_name" content="dotnet之美" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-27T08:36:33+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="【系统设计】设计一个限流组件" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-27T08:36:33+00:00","datePublished":"2022-05-27T08:36:33+00:00","description":"限速器 (Rate Limiter) 相信大家都不会陌生，在网络系统中，限速器可以控制客户端发送流量的速度，比如 TCP, QUIC 等协议。而在 HTTP 的世界中， 限速器可以限制客户端在一段时间内发送请求的次数，如果超过设定的阈值，多余的请求就会被丢弃。 生活中也有很多这样的例子，比如 用户一分钟最多能发 5 条微博 用户一天最多能投 3 次票 用户一小时登录超过5次后，需要等待一段时间才能重试。","headline":"【系统设计】设计一个限流组件","mainEntityOfPage":{"@type":"WebPage","@id":"/cnblog/2022/05/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6.html"},"url":"/cnblog/2022/05/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="dotnet之美" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">dotnet之美</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">【系统设计】设计一个限流组件</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-05-27T08:36:33+00:00" itemprop="datePublished">May 27, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>限速器 (Rate Limiter) 相信大家都不会陌生，在网络系统中，限速器可以控制客户端发送流量的速度，比如 TCP, QUIC 等协议。而在 HTTP 的世界中， 限速器可以限制客户端在一段时间内发送请求的次数，如果超过设定的阈值，多余的请求就会被丢弃。</p>

<p>生活中也有很多这样的例子，比如</p>

<ul>
  <li>用户一分钟最多能发 5 条微博</li>
  <li>用户一天最多能投 3 次票</li>
  <li>用户一小时登录超过5次后，需要等待一段时间才能重试。</li>
</ul>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_025751.png" alt="" /></p>

<p>限速器（Rate Limiter）有很多好处，可以防止一定程度的 Dos 攻击，也可以屏蔽掉一些网络爬虫的请求，避免系统资源被耗尽，导致服务不可用。</p>

<h2 id="设计要求">设计要求</h2>

<p>让我们从一个面试开始吧！</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_030844.png" alt="" /></p>

<p>面试官：你好，我想考察一下你的设计能力，如果让你设计一个限速器 (Rate Limiter)，你会怎么做？</p>

<p>面试者： 我们需要什么样的限速器？ 它是在客户端限速还是在服务端限速？</p>

<p>面试官：这个问题很好，没有固定要求，取决于你的设计。</p>

<p>面试者：我想了解一下限速的规则，我们是根据 IP、UserId，或者手机号码进行限速吗？</p>

<p>面试官：这个不固定，限速器应该是灵活的，要能很方便的支持不同的规则。</p>

<p>面试者：如果请求被限制了，需要提示给用户吗？</p>

<p>面试官：需要提示，要给用户提供良好的体验。</p>

<p>面试者：好吧，那系统的规模是多大的？是单机还是分布式场景？</p>

<p>面试官：我们是 TOC 的产品， 系统流量很大，并且是分布式的环境， 所以限速器要支持海量请求。</p>

<p>面试者：（小声嘀咕）你这是造火箭呢？</p>

<p>我们总结一下限速器的设计要求：</p>

<ul>
  <li>低延迟，性能要好</li>
  <li>需要适用于分布式场景。</li>
  <li>用户的请求受到限制时，需要提示具体的原因。</li>
  <li>高容错，如果限速器故障，不应该影响整个系统。</li>
</ul>

<h2 id="限速器应该放在哪里">限速器应该放在哪里？</h2>

<p>从系统整体的角度上来看，我们的限速器应该放在哪里？通常有三种选择，如下</p>

<p><strong>客户端</strong></p>

<p>是的，我们可以在客户端设置限速器。但是有个问题是，我们都知道在 Web 前端做一些限制实际上是不安全的，同样客户端也是一样的， 限速客户端可以做，但是远远不够。</p>

<p><strong>服务端</strong></p>

<p>在服务端设置限速器是很常见且安全的，如下</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_044834.png" alt="" /></p>

<p><strong>中间件</strong></p>

<p>还有一种做法是，我们可以提供一个单独的限速中间件，如下</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_045114.png" alt="" /></p>

<p>假如限速器设置了每秒最大允许2个请求，那么客户端发出的多余的请求就会被拒绝，并返回 HTTP 状态码 429, 表示用户发送了太多的请求。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_045444.png" alt="" /></p>

<p>实际上，很多网关都有限速的实现，包括认证、IP 白名单功能。</p>

<p>限速器应该放在哪里？没有固定的答案，它取决于公司的技术栈，系统规模。</p>

<h2 id="限速算法">限速算法</h2>

<p>实际上，我们可以用算法实现限速器，下面是几种经典的限速算法，每种算法都有自己的优点和缺点，了解这些可以帮助我们选择更适合的算法。</p>

<ul>
  <li>令牌桶 （Token bucket）</li>
  <li>漏桶（Leaking bucket）</li>
  <li>固定窗口计数器（Fixed window counter）</li>
  <li>滑动窗口日志（Sliding window log）</li>
  <li>滑动窗口计数器（Sliding window counter）</li>
</ul>

<h2 id="令牌桶算法">令牌桶算法</h2>

<p>令牌桶算法是实现限速使用很广泛的算法，它很简单也很好理解。</p>

<p>令牌桶是固定容量的容器。</p>

<p>一方面，按照一定的速率，向桶中添加令牌，桶装满后，多余的令牌就会被丢弃。</p>

<p>如下图，桶的容量为4，每次填充2个令牌。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_055726.png" alt="" /></p>

<p>另一方面，一个请求消耗一个令牌，如果桶中没有令牌了，则拒绝请求。直到下个时间段，继续向桶中填充新的令牌。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_061100.png" alt="" /></p>

<p>令牌桶算法有两个重要的参数，分别是桶大小和填充率，另外有时候可能需要多个桶，比如多个 api 限速的规则是不一样的。</p>

<p>令牌桶算法的优点是简单易实现，并且允许短时间的流量并发。缺点是，在应对流量变化时，正确地调整桶大小和填充率，会比较有挑战性。</p>

<h2 id="漏桶算法">漏桶算法</h2>

<p>漏桶算法和令牌桶算法是类似的，同样有一个固定容量的桶。</p>

<p>一方面，当一个请求进来时，会被填充到桶里，如果桶满了，就拒绝这个请求。</p>

<p>另一方面，想象桶下面有一个漏洞，桶里的元素以固定的速率流出。</p>

<p>通常可以用先入先出的队列实现，如下图</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_071702.png" alt="" /></p>

<p>漏桶算法有两个参数，分别是桶大小和流出率，优点是使用队列易实现，缺点是，面对突发流量时，虽然有的请求已经推到队列中了，但是由于消费的速率是固定的，存在效率问题。</p>

<h2 id="固定窗口计数器算法">固定窗口计数器算法</h2>

<p>固定窗口计数器算法的工作原理是，把时间划分成固定大小的时间窗口，每个窗口分配一个计数器，接收到一个请求，计数器就加一，一旦计数器达到设定的阈值，新的请求就会被丢弃，直到新的时间窗口，新的计数器。</p>

<p>让我们通过下面的例子，来看看它是如何工作的。一个时间窗口是1秒，每秒最多允许3个请求，超出的请求就会被丢弃。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_082200.png" alt="" /></p>

<p>不过这个算法有一个问题是，如果在时间窗口的边缘出现突发流量时，可能会导致通过的请求数超过阈值，什么意思呢？我们看看下面的情况</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_083538.png" alt="" /></p>

<p>一个时间窗口是1分钟，每分钟最多允许5个请求。如果前一个时间窗口的后半段有5个请求，后一个时间窗口的前半段有5个请求，也就是 2:00:30 到 2:01:30 的一分钟内，是可以通过10个请求的，这明显超过了我们设置的阈值。</p>

<p>固定窗口计数器的优点是，简单易于理解，缺点是，时间窗口的边缘应对流量高峰时，可能会让通过的请求数超过阈值。</p>

<h2 id="滑动窗口日志算法">滑动窗口日志算法</h2>

<p>我们上面看到了，固定窗口计数器算法有一个问题，在窗口边缘可能会突破限制，而滑动窗口日志算法可以解决这个问题。</p>

<p>它的工作原理是，假如设定1分钟内最多允许2个请求，每个请求都需要记录请求时间，比如保存在 Redis  的 sorted sets  中，保存之后还需要删除掉过时的日志，过时日志是如何定义的？比如某次请求的时间是 1:01:36，那么往前推1分钟，1:00:36 之前的日志都算过时的，需要从集合中删掉。同时，判断集合中的数量是否大于阈值，如果大于2则丢弃请求，如果小于或等于2，则处理这个请求。</p>

<p>让我们看看下面的例子</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_091118.png" alt="" /></p>

<ol>
  <li>在 1:00:01 来了一个请求，第一步，记录请求时间到日志中，第二步，判断是否有过时的日志, 也就是 0:59:01 之前的日志，明显没有，第三步判断日志中的数量，没有大于2，处理这次请求。</li>
  <li>在 1:00:30 来了一个请求，执行上面的三个步骤，最后处理这次请求。</li>
  <li>在 1:00:50 的新请求，没有过时的日志，然后发现日志的数量为3，拒绝这次请求。</li>
  <li>在 1:01:40 的新请求，清除2条过时的日志，也就是 1:00:40 之前的日志，此时，日志中的数量为2，处理这次请求。</li>
</ol>

<p>这个算法实现的限速非常准确，但是它可能会消耗较多的内存。</p>

<h2 id="滑动窗口计数器算法">滑动窗口计数器算法</h2>

<p>滑动窗口计数器可以说是固定窗口计数器的升级版，上面提到了，固定窗口计数器存在窗口边缘可能会有超出限制的情况，如下</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_100155.png" alt="" /></p>

<p>而滑动窗口把固定的窗口又分成了很多小的窗口单位，比如下图，每个固定窗口的大小为1分钟，又拆分成了6份，每次移动一个小的单位，保证总和不超过阈值。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_102254.png" alt="" /></p>

<p>这样就可以避免上面的窗口边缘超出限制的问题。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_103143.png" alt="" /></p>

<h2 id="使用-redis-实现高效计数器">使用 Redis 实现高效计数器</h2>

<p>限速器算法的思想其实很简单，我们需要使用计数器记录用户的请求，如果超过阈值，服务这个请求，否则，拒绝这个请求。</p>

<p>一个很重要的问题是，我们应该把计数器放在哪里？我们知道，磁盘速度比较慢，使用数据库明显是不太现实的方案，想要更快的话，可以使用内存缓存，最常见的就是 Redis，是的，我们可以使用 Redis 实现高效计数器，如下</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_111126.png" alt="" /></p>

<h2 id="规则引擎">规则引擎</h2>

<p>Lyft  是一个开源的限速组件，可以供我们参考，它通过 Yaml 配置文件实现灵活的限速规则，看下面的示例</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_112439.png" alt="" /></p>

<p>这个配置表示系统每天只能发送 5 条营销信息。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_112655.png" alt="" /></p>

<p>这个配置表示 1分钟的登录次数不能超过 5 次。</p>

<p>可以看到，基于配置文件，声明式的限速规则是非常灵活的，我们可以把配置文件保存到磁盘中。</p>

<h2 id="返回限速信息">返回限速信息</h2>

<p>当请求超过限制时，限速器会拒绝掉其他的请求，这样其实不够，为了更好的用户体验，我们需要返回友好的错误信息给用户，并提示。</p>

<p>首先，限速器拒绝请求后，可以返回 HTTP 状态码 429，表示请求过多。</p>

<p>其次，我们可以返回更详细的信息，比如，剩余请求次数、等待时间等。一种很常见的做法时，把这些信息放到 Http 响应的 Header 中返回，如下</p>

<ul>
  <li>X-Ratelimit-Remaining：表示剩余次数</li>
  <li>X-Ratelimit-Limit：表示客户端每个时间窗口可以进行多少次调用</li>
  <li>X-Ratelimit-Retry-After：表示等待多长时间可以进行重试</li>
</ul>

<p>看起来不错！让我们看看现在的架构设计</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220510_114212.png" alt="" /></p>

<p>首先，限速规则存储在磁盘上，因为要经常访问，可以添加到缓存中。当客户端向服务器发送请求时，会先发送到限速中间件。限速中间件从缓存中拉取限速规则，同时把请求数据写入到 Redis 的计数器，然后判断是否超出限制。如果没有超出限制，把请求转发给我们的后端服务器。如果超出了限制，第一种方案，丢弃多余的请求，返回 429，第二种方案，把多余的请求推送到消息队列中，后续再进行处理。使用哪种方案，取决于您的实际场景。</p>

<h2 id="分布式环境">分布式环境</h2>

<p>构建一个在单服务器运行的限速器是很简单的，但是在分布式环境中，支持多台服务器，那就完全是另外一回事了。</p>

<p>我们主要要考虑两个问题：</p>

<ul>
  <li>并发问题</li>
  <li>数据同步问题</li>
</ul>

<p>并发问题，我们的限速器的工作原理是，当接收到新的请求时，从 Redis 中读取计数器 counter，然后做加一的操作，在高并发场景中，可能存在多个线程读到了旧的值，比如，两个线程同时读取到 counter 的值为3，然后都把 counter 改成了4，这样是有问题的，其实最终应该是 5。</p>

<p>有朋友说，我们可以用锁，但实际上，锁的效率是不高的。解决这个问题通常有两个方案，第一个是使用 Lua 脚本，第二个是使用 Redis 的 sorted sets 数据结构，具体的细节本文不做过多介绍。</p>

<p>数据同步问题，在流量比较大的情况下，一个限速器是难以支撑的，我们需要多个限速器。由于 Web 层通常是无状态的，客户端的请求会随机发送给不同的限速器，如下</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220511_121021.png" alt="" /></p>

<p>这种情况下，如果没有数据同步，我们的限速器肯定是没办法正常工作的。</p>

<p>我们可以使用像 Redis 这样的集中式数据存储，如下</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220511_121317.png" alt="" /></p>

<h2 id="性能优化">性能优化</h2>

<p>当我们的系统是面向全球用户时，为了让各个地区的用户都能有一个不错的体验，通常会在不同的地区设置多个数据中心。另外，现在很多云服务商在全球各地都有边缘服务器，流量会自动路由到最近的边缘服务器，来减少网络的延迟。</p>

<p><img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20220511_122036.png" alt="" /></p>

<p>当然，存在多个数据中心时，可能还要考虑到数据的最终一致性。</p>

<h2 id="总结">总结</h2>

<p>在本文中，我们讨论了不同的限速算法，以及它们有优缺点，算法包括：</p>

<ul>
  <li>令牌桶</li>
  <li>漏桶</li>
  <li>固定窗口计数器</li>
  <li>滑动窗口日志</li>
  <li>滑动窗口计数器</li>
</ul>

<p>然后，我们讨论了分布式环境中的系统架构，并发问题和数据同步问题，和灵活配置的限速规则，最后你会发现，实现一个限速器，其实没有那么难！</p>

<p>希望对您有用！</p>

<p>译：等天黑</p>

<p>作者：Alex Xu</p>

<p>来源：《System Design Interview》</p>

<p>简介: Alex Xu 是一位经验丰富的软件工程师, 曾在 Twitter, Apple 和 Oracle 任职，来自CS名校卡内基梅隆大学，热衷于系统设计。
 <img src="https://blog-1259586045.cos.ap-shanghai.myqcloud.com/wechat_logo_s1.png" alt="" /></p>
<blockquote>
  <p>作者:SpringLeee
原文:https://www.cnblogs.com/myshowtime/p/16313623.html</p>
</blockquote>

  </div><a class="u-url" href="/cnblog/2022/05/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">dotnet之美</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">dotnet之美</li><li><a class="u-email" href="mailto:springhgui@outlook.com">springhgui@outlook.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>分享dotnet技术.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
