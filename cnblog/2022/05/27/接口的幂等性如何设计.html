<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>接口的幂等性如何设计？ | dotnet之美</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="接口的幂等性如何设计？" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前言 所谓幂等: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。 我们在开发中主要操作也就是CURD,其中读取操作和删除操作是天然幂等的，我们所关心的就是创建操作、更新操作。 创建操作一定是非幂等的因为要涉及到新数据的产生，而更新操作有可能幂等有可能非幂等，这个要看具体业务场景。 ## 1、前端重复提交 就好比有个新增商品的功能，有个保存按钮，如果前端连续多次点击保存，后端就会收到多次请求接口，如果没做好幂等就会重复创建了多条记录, 就会出现脏数据。 这个也就是我们所说的如何防止前端重复提交的问题。 2、接口超时重试 当我们调取第三方接口的时候,有可能会因为网络等原因导致调用失败，所以我们会对接口调用添加失败重试的机制,Spring可以通过@Retryable注解实现重试机制。 既然重试就可能出现重复调用接口。这时再次调用时如果没有做好幂等,就可能出现脏数据。 3、消息重复消费 这个是无法避免的，因为我们说MQ在生产端和消费端都有重试机制，也就是同一消息很可能会被重复消费。 如果业务保证多次消费的结果是一样的那没问题，但是如果业务无法满足那就需要通过其它方式来保证消费端的幂等。" />
<meta property="og:description" content="前言 所谓幂等: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。 我们在开发中主要操作也就是CURD,其中读取操作和删除操作是天然幂等的，我们所关心的就是创建操作、更新操作。 创建操作一定是非幂等的因为要涉及到新数据的产生，而更新操作有可能幂等有可能非幂等，这个要看具体业务场景。 ## 1、前端重复提交 就好比有个新增商品的功能，有个保存按钮，如果前端连续多次点击保存，后端就会收到多次请求接口，如果没做好幂等就会重复创建了多条记录, 就会出现脏数据。 这个也就是我们所说的如何防止前端重复提交的问题。 2、接口超时重试 当我们调取第三方接口的时候,有可能会因为网络等原因导致调用失败，所以我们会对接口调用添加失败重试的机制,Spring可以通过@Retryable注解实现重试机制。 既然重试就可能出现重复调用接口。这时再次调用时如果没有做好幂等,就可能出现脏数据。 3、消息重复消费 这个是无法避免的，因为我们说MQ在生产端和消费端都有重试机制，也就是同一消息很可能会被重复消费。 如果业务保证多次消费的结果是一样的那没问题，但是如果业务无法满足那就需要通过其它方式来保证消费端的幂等。" />
<link rel="canonical" href="/cnblog/2022/05/27/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1.html" />
<meta property="og:url" content="/cnblog/2022/05/27/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1.html" />
<meta property="og:site_name" content="dotnet之美" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-27T08:36:37+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="接口的幂等性如何设计？" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-27T08:36:37+00:00","datePublished":"2022-05-27T08:36:37+00:00","description":"前言 所谓幂等: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。 我们在开发中主要操作也就是CURD,其中读取操作和删除操作是天然幂等的，我们所关心的就是创建操作、更新操作。 创建操作一定是非幂等的因为要涉及到新数据的产生，而更新操作有可能幂等有可能非幂等，这个要看具体业务场景。 ## 1、前端重复提交 就好比有个新增商品的功能，有个保存按钮，如果前端连续多次点击保存，后端就会收到多次请求接口，如果没做好幂等就会重复创建了多条记录, 就会出现脏数据。 这个也就是我们所说的如何防止前端重复提交的问题。 2、接口超时重试 当我们调取第三方接口的时候,有可能会因为网络等原因导致调用失败，所以我们会对接口调用添加失败重试的机制,Spring可以通过@Retryable注解实现重试机制。 既然重试就可能出现重复调用接口。这时再次调用时如果没有做好幂等,就可能出现脏数据。 3、消息重复消费 这个是无法避免的，因为我们说MQ在生产端和消费端都有重试机制，也就是同一消息很可能会被重复消费。 如果业务保证多次消费的结果是一样的那没问题，但是如果业务无法满足那就需要通过其它方式来保证消费端的幂等。","headline":"接口的幂等性如何设计？","mainEntityOfPage":{"@type":"WebPage","@id":"/cnblog/2022/05/27/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1.html"},"url":"/cnblog/2022/05/27/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="dotnet之美" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">dotnet之美</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">接口的幂等性如何设计？</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-05-27T08:36:37+00:00" itemprop="datePublished">May 27, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="https://img2022.cnblogs.com/blog/1090617/202205/1090617-20220525093722695-2057195228.jpg" alt="" /></p>
<h4 id="前言">前言</h4>

<p>所谓幂等: <strong>多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</strong>。</p>

<p>我们在开发中主要操作也就是<code class="language-plaintext highlighter-rouge">CURD</code>,其中<strong>读取</strong>操作和<strong>删除</strong>操作是天然幂等的，我们所关心的就是<strong>创建</strong>操作、<strong>更新</strong>操作。</p>

<p><strong>创建操作</strong>一定是非幂等的因为要涉及到新数据的产生，而<strong>更新操作</strong>有可能幂等有可能非幂等，这个要看具体业务场景。</p>

<p>##</p>

<h4 id="1前端重复提交">1、前端重复提交</h4>

<p>就好比有个新增商品的功能，有个<code class="language-plaintext highlighter-rouge">保存按钮</code>，如果前端连续多次点击保存，后端就会收到多次请求接口，如果没做好幂等就会重复创建了多条记录,<br />
 就会出现脏数据。</p>

<p>这个也就是我们所说的如何防止前端重复提交的问题。</p>

<h4 id="2接口超时重试">2、接口超时重试</h4>

<p>当我们调取第三方接口的时候,有可能会因为网络等原因导致调用失败，所以我们会对接口调用添加失败重试的机制,Spring可以通过<code class="language-plaintext highlighter-rouge">@Retryable</code>注解实现重试机制。</p>

<p>既然重试就可能出现重复调用接口。这时再次调用时如果没有做好幂等,就可能出现脏数据。</p>

<h4 id="3消息重复消费">3、消息重复消费</h4>

<p>这个是无法避免的，因为我们说MQ在生产端和消费端都有<strong>重试机制</strong>，也就是同一消息很可能会被重复消费。</p>

<p>如果业务保证多次消费的结果是一样的那没问题，但是如果业务无法满足那就需要通过其它方式来保证消费端的幂等。</p>

<p>##</p>

<h4 id="1插入前先判断数据是否存在">1、插入前先判断数据是否存在</h4>

<p>这种是最基础的，也是我们在开发中必须要做的。我们会在插入或者更新前先判断下,当前这个数据数据库中是否已经存在，如果不存在则不允许重复插入，不存在则可插入。</p>

<p>代码示例如下:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public void save(Goods goods) {
        // 1、先通过商品唯一code，查询数据库属否存在   
        Goods goods = findGoods(goods.getCode);
        // 2、如果这条数据在db里已经存在了，此时就直接返回了   
        if (goods != null) {
            return;
        }
        // 3、如果要是这条数据在db里不存在，此时就会执行数据插入逻辑了   
        insertGoods(goods);
    }
</code></pre></div></div>

<h4 id="2前端做一些交互控制">2、前端做一些交互控制</h4>

<p>好比有个新增商品的功能，有个<code class="language-plaintext highlighter-rouge">保存按钮</code>,用户点击保存按钮后，立马按钮置灰，或者页面跳转到商品列表页面，这样可以防止很大部分的前端重复提交。</p>

<p>##</p>

<p>上面两种初级方法，在高并发下显然是无法保证接口幂等的，所以在高并发下，我们来如何保证接口的幂等呢，这里整理几种常见的解决办法。</p>

<h4 id="1基于悲观锁">1、基于悲观锁</h4>

<p><code class="language-plaintext highlighter-rouge">定义</code>: 当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p>

<p>这里以更新商品订单状态来举例：一般订单有<strong>订单创建</strong>、<strong>订单确认</strong>、<strong>订单支付</strong>、<strong>订单完成</strong>、<strong>取消订单</strong>等订单流程。</p>

<p>当我更新订单状态为<strong>订单完成</strong>的时候，我们首先通过判断该订单的状态是否是<strong>订单支付</strong>，如果是不是则直接返回，否则更新状态为已完成。</p>

<p>伪代码示例如下</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  begin; -- 1.开始事务
  -- 查询订单，判断状态
  select order_no,status from order where order_no='20200524-1' 
  if（status !=订单支付状态）{
        -- 非订单支付状态，不能更新为已完成；
        return ;
    }
  -- 更新完成
  update order set status='订单完成' order_no='20200524-1' 
   commit; -- 2.提交事务
</code></pre></div></div>

<p>这是我们常见的一种写法，但这种写法在高并发环境下，可能会造成一个业务被执行两次的情况发生：</p>

<p>同时有两个请求过来,大家几乎同时查数据库订单状态，都是<strong>订单支付</strong>状态，然后就支持接下来一系列操作，这就导致一个业务被执行了两次，如果接下来一系列操作不是幂等的</p>

<p>那么就会出现脏数据。这里我们就可以通过悲观锁实现，也就是添加<code class="language-plaintext highlighter-rouge">for update</code>字段。</p>

<p>伪代码示例如下</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  begin;  --  1.开始事务
  --  查询订单，判断状态
  select order_no,status from order where order_no='20200524-1' for update 
  if（status !=订单支付状态）{
        -- 非订单状态，不能更新为已完成；
        return ;
    }
 --  更新完成
  update order set status='完成' order_no='20200524-1' 
   commit; -- 2.提交事务
</code></pre></div></div>

<p>1）这里order_no需要添加<code class="language-plaintext highlighter-rouge">索引</code>，否则会<code class="language-plaintext highlighter-rouge">锁表</code>。</p>

<p>2） 悲观锁在同一事务操作过程中，锁住了一行数据。悲观锁性能不佳所以一般不建议用悲观锁做这个事情。</p>

<h4 id="2基于乐观锁">2、基于乐观锁</h4>

<p><code class="language-plaintext highlighter-rouge">定义</code>:乐观锁就是很乐观,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用<code class="language-plaintext highlighter-rouge">版本号机制</code>。</p>

<p>所谓的乐观锁就是在表中新增一个<code class="language-plaintext highlighter-rouge">version</code>(版本号)字段。</p>

<p>通过版本号的方式，来控制update的操作的幂等性，用户查询出要修改的数据，系统将数据返回给页面，将数据版本号放入隐藏域，用户修改数据，点击提交，将版本号一同提交</p>

<p>给后台，后台使用版本号作为更新条件。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>update set version = version +1 ,count=count+1 where id =xxx and version = ${version};
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">注意</code>:乐观锁能够保证的是<strong>update的操作的幂等性</strong>,如果你的update本身就是幂等操作，或者install操作那就不能用乐观锁了。</p>

<h4 id="3基于状态码">3、基于状态码</h4>

<p>很多业务表，都是有状态的，比如订单表,一般订单有<strong>1-订单创建</strong>、<strong>2-订单确认</strong>、<strong>3-订单支付</strong>、 <strong>4-订单完成</strong>、<strong>5-取消订单</strong>等订单流程，当我们更新订单状态</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>update order_table set status=3 where order_no='20200524-1' and status=2;
</code></pre></div></div>

<p>第一个请求时，成功把 <strong>订单确认</strong> 状态修改成 <strong>订单支付</strong>,sql执行结果的影响行数是1。</p>

<p>第二个请求时，同样想把 <strong>订单确认</strong> 状态修改成 <strong>订单支付</strong>,但是sql执行结果的影响行数为0。如果是0，那么我们直接可以返回成功了。而不需要做接下来的业务操作，以此来保证保证</p>

<p>接口的幂等性。</p>

<h4 id="4基于唯一索引">4、基于唯一索引</h4>

<p>一般来讲悲观锁、乐观锁、状态码作用于update操作来实现幂等，而唯一索引是针对install操作来保证幂等。</p>

<p>1） 创建订单时，前端先通过接口获取订单号,再请求后端时带入订单号,订单表中订单号添加唯一索引，如果存在插入相同订单号则直接报错。</p>

<p>2） 消费MQ消息时，<code class="language-plaintext highlighter-rouge">messageId</code>是唯一的，我们可以新添加一种消费记录表，将messageId作为主键，如果重复消费那么就会存在相同的messageId，插入直接报错。</p>

<h4 id="5基于分布式锁">5、基于分布式锁</h4>

<p>分布式锁实现幂等性的逻辑就是，请求过来时，先去尝试获得分布式锁，如果获得成功，就执行业务逻辑，反之获取失败的话，就舍弃请求直接返回成功。</p>

<p>其实前面介绍过的悲观锁，本质是使用了数据库的分布式锁，都是将多个操作打包成一个原子操作，保证幂等。但由于数据库分布式锁的性能不太好，</p>

<p>我们可以改用：redis或zookeeper来实现分布式锁。</p>

<h4 id="6基于-token">6、基于 Token</h4>

<blockquote>
  <p>token方案的特点就是:需要两次请求才能完成一次业务的操作。</p>
</blockquote>

<p>一般包括两个请求阶段：</p>

<p>1）客户端请求<code class="language-plaintext highlighter-rouge">申请获取token</code>，服务端生成token返回。</p>

<p>2）第二次请求<code class="language-plaintext highlighter-rouge">带着这个token</code>，服务端验证token，完成业务操作。
 <img src="https://img2022.cnblogs.com/blog/1090617/202205/1090617-20220525093754156-164022587.jpg" alt="" /> 
<code class="language-plaintext highlighter-rouge">注意</code>:，在验证token是否存在，不要用redis.get(token)之后，在用redis.del(token)，这样不是原子操作在高并发情况下依然会存在幂等问题。</p>

<p>我们可以直接用<code class="language-plaintext highlighter-rouge">redis.del(token)</code>的方式：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis&gt; SET key1 "Hello"
OK
redis&gt; SET key2 "World"
OK
redis&gt; DEL key1 key2 key3
(integer) 2
redis&gt; 
</code></pre></div></div>

<p>我们看返回是否大于0，就知道是否有数据了，而且因为redis命令操作是单线程的，所以不会出现同时返回1，所以是能够保证幂等的。</p>

<p>这种方式最大的缺点需要两次请求，其实简单点我们可以进行一次请求，那就是前端生成唯一token，而不通过后端获取。
 <img src="https://img2022.cnblogs.com/blog/1090617/202205/1090617-20220525093806022-402769654.jpg" alt="" /> 
<code class="language-plaintext highlighter-rouge">Setnx 命令</code></p>

<p>在指定的 key 不存在时，为 key 设置指定的值。设置成功，返回1。 设置失败，返回 0。</p>

<p><code class="language-plaintext highlighter-rouge">实例</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis&gt; EXISTS job      --  job 不存在
(integer) 0

redis&gt; SETNX job "programmer"  --  job 设置成功
(integer) 1

redis&gt; SETNX job "code-farmer" --  尝试覆盖 job ，失败
(integer) 0

redis&gt; GET job                 --  没有被覆盖
"programmer"
</code></pre></div></div>

<p>如果返回1则说明第一次请求，如果返回0则说明不是第一次请求，直接返回。</p>

<p>这里需要注意的是<code class="language-plaintext highlighter-rouge">Setnx命令</code>key值不会自动过期的，所以不清除会一直占用内存，我们可以借助<code class="language-plaintext highlighter-rouge">Expire命令</code>来设置有效时间。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis&gt; SETNX mykey "programmer"  --  job 设置成功
(integer) 1
--  如果设置成功，那么设置将该键的超时设置为 10 秒
redis&gt; expire mykey 10 &gt; 作者:雨点的名字 &gt; 原文:https://www.cnblogs.com/qdhxhz/p/16308097.html
</code></pre></div></div>

  </div><a class="u-url" href="/cnblog/2022/05/27/%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">dotnet之美</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">dotnet之美</li><li><a class="u-email" href="mailto:springhgui@outlook.com">springhgui@outlook.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>分享dotnet技术.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
