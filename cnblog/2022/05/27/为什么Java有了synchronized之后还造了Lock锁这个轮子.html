<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>为什么Java有了synchronized之后还造了Lock锁这个轮子？ | dotnet之美</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="为什么Java有了synchronized之后还造了Lock锁这个轮子？" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="众所周知，synchronized和Lock锁是java并发编程中两大利器，可以用来解决线程安全的问题。但是为什么Java有了synchronized之后还是提供了Lock接口这个api，难道仅仅只是重复造了轮子这么简单么？本文就来探讨一下这个问题。 谈到这个问题，其实很多同学第一反应都会说，Lock锁的性能比synchronized好，synchronized属于重量级的锁。但是在JDK 1.6版本之后，JDK对synchronized进行了一系列性能的优化，synchronized的性能其实有了大大的提升（如果不清楚的同学可以看一下 synchronized真的很重么？这篇文章，文章内详细的说明JDK对synchronized做了哪些优化），那么既然性能不是问题，那么主要的问题是什么呢？ synchronized抢占锁的特性 我们先来看一下synchronized抢占锁的特性。synchronized在抢占锁的时候，如果抢占不到，线程直接就进入阻塞状态了，而线程进入阻塞状态，其实什么也干不了，也释放不了线程已经占有的资源，并且也无法主动或者被动打断阻塞获取锁的操作，只有等别的线程释放锁之后才会被唤醒来重新获取锁。 synchronized阻塞获取锁产生的问题 那synchronized这种获取锁阻塞的特性，有什么问题么？其实有一种很重要的问题，那就是会产生死锁的问题。 那什么是死锁？死锁是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待的现象。 举个例子来说，线程1先对加A加锁，线程2对B加锁。代码运行到某一时刻，线程1需要对B加锁，但是此时B的锁已经被线程2占有，于是线程1就会阻塞，与此同时线程2同时也需要对A加锁，发现A已经被线程1持有，也会进入阻塞，于是线程1和线程2都在等对方释放资源，就产生了死锁的问题，并且由于synchronized阻塞的特性，线程无法主动或者被动停止阻塞，势必会导致这个死锁永远无法通过主动或者人为干预（其它线程干预）来解决。 那么有什么好的办法来解决阻塞导致死锁的问题呢？ 我们分析一下死锁产生的问题主要是线程都在相互等待其它线程释放资源导致的，基于这个问题我们思考一下，如果一个线程获取不到锁，然后就停止获取锁，不阻塞，或者是阻塞一会就不再阻塞，又或是阻塞过程中被其他线程打断，那样这是不是就不是产生死锁的问题了。 就拿上面的例子来说，假设线程1获取B的阻塞锁超过一定时间，主动放弃获取B的锁，那么线程1代码就可以继续往下执行，当执行完之后，线程1释放了A锁，此时线程2就能获取到A的锁，那么线程2就可以继续执行了，这样是不是死锁的问题就完美解决了。 其实Lock锁就提供了上述提到的几种解决方案的api，接下来我们就来看看Lock锁提供的api。 Lock锁" />
<meta property="og:description" content="众所周知，synchronized和Lock锁是java并发编程中两大利器，可以用来解决线程安全的问题。但是为什么Java有了synchronized之后还是提供了Lock接口这个api，难道仅仅只是重复造了轮子这么简单么？本文就来探讨一下这个问题。 谈到这个问题，其实很多同学第一反应都会说，Lock锁的性能比synchronized好，synchronized属于重量级的锁。但是在JDK 1.6版本之后，JDK对synchronized进行了一系列性能的优化，synchronized的性能其实有了大大的提升（如果不清楚的同学可以看一下 synchronized真的很重么？这篇文章，文章内详细的说明JDK对synchronized做了哪些优化），那么既然性能不是问题，那么主要的问题是什么呢？ synchronized抢占锁的特性 我们先来看一下synchronized抢占锁的特性。synchronized在抢占锁的时候，如果抢占不到，线程直接就进入阻塞状态了，而线程进入阻塞状态，其实什么也干不了，也释放不了线程已经占有的资源，并且也无法主动或者被动打断阻塞获取锁的操作，只有等别的线程释放锁之后才会被唤醒来重新获取锁。 synchronized阻塞获取锁产生的问题 那synchronized这种获取锁阻塞的特性，有什么问题么？其实有一种很重要的问题，那就是会产生死锁的问题。 那什么是死锁？死锁是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待的现象。 举个例子来说，线程1先对加A加锁，线程2对B加锁。代码运行到某一时刻，线程1需要对B加锁，但是此时B的锁已经被线程2占有，于是线程1就会阻塞，与此同时线程2同时也需要对A加锁，发现A已经被线程1持有，也会进入阻塞，于是线程1和线程2都在等对方释放资源，就产生了死锁的问题，并且由于synchronized阻塞的特性，线程无法主动或者被动停止阻塞，势必会导致这个死锁永远无法通过主动或者人为干预（其它线程干预）来解决。 那么有什么好的办法来解决阻塞导致死锁的问题呢？ 我们分析一下死锁产生的问题主要是线程都在相互等待其它线程释放资源导致的，基于这个问题我们思考一下，如果一个线程获取不到锁，然后就停止获取锁，不阻塞，或者是阻塞一会就不再阻塞，又或是阻塞过程中被其他线程打断，那样这是不是就不是产生死锁的问题了。 就拿上面的例子来说，假设线程1获取B的阻塞锁超过一定时间，主动放弃获取B的锁，那么线程1代码就可以继续往下执行，当执行完之后，线程1释放了A锁，此时线程2就能获取到A的锁，那么线程2就可以继续执行了，这样是不是死锁的问题就完美解决了。 其实Lock锁就提供了上述提到的几种解决方案的api，接下来我们就来看看Lock锁提供的api。 Lock锁" />
<link rel="canonical" href="/cnblog/2022/05/27/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E6%9C%89%E4%BA%86synchronized%E4%B9%8B%E5%90%8E%E8%BF%98%E9%80%A0%E4%BA%86Lock%E9%94%81%E8%BF%99%E4%B8%AA%E8%BD%AE%E5%AD%90.html" />
<meta property="og:url" content="/cnblog/2022/05/27/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E6%9C%89%E4%BA%86synchronized%E4%B9%8B%E5%90%8E%E8%BF%98%E9%80%A0%E4%BA%86Lock%E9%94%81%E8%BF%99%E4%B8%AA%E8%BD%AE%E5%AD%90.html" />
<meta property="og:site_name" content="dotnet之美" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-27T08:36:17+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="为什么Java有了synchronized之后还造了Lock锁这个轮子？" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-27T08:36:17+00:00","datePublished":"2022-05-27T08:36:17+00:00","description":"众所周知，synchronized和Lock锁是java并发编程中两大利器，可以用来解决线程安全的问题。但是为什么Java有了synchronized之后还是提供了Lock接口这个api，难道仅仅只是重复造了轮子这么简单么？本文就来探讨一下这个问题。 谈到这个问题，其实很多同学第一反应都会说，Lock锁的性能比synchronized好，synchronized属于重量级的锁。但是在JDK 1.6版本之后，JDK对synchronized进行了一系列性能的优化，synchronized的性能其实有了大大的提升（如果不清楚的同学可以看一下 synchronized真的很重么？这篇文章，文章内详细的说明JDK对synchronized做了哪些优化），那么既然性能不是问题，那么主要的问题是什么呢？ synchronized抢占锁的特性 我们先来看一下synchronized抢占锁的特性。synchronized在抢占锁的时候，如果抢占不到，线程直接就进入阻塞状态了，而线程进入阻塞状态，其实什么也干不了，也释放不了线程已经占有的资源，并且也无法主动或者被动打断阻塞获取锁的操作，只有等别的线程释放锁之后才会被唤醒来重新获取锁。 synchronized阻塞获取锁产生的问题 那synchronized这种获取锁阻塞的特性，有什么问题么？其实有一种很重要的问题，那就是会产生死锁的问题。 那什么是死锁？死锁是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待的现象。 举个例子来说，线程1先对加A加锁，线程2对B加锁。代码运行到某一时刻，线程1需要对B加锁，但是此时B的锁已经被线程2占有，于是线程1就会阻塞，与此同时线程2同时也需要对A加锁，发现A已经被线程1持有，也会进入阻塞，于是线程1和线程2都在等对方释放资源，就产生了死锁的问题，并且由于synchronized阻塞的特性，线程无法主动或者被动停止阻塞，势必会导致这个死锁永远无法通过主动或者人为干预（其它线程干预）来解决。 那么有什么好的办法来解决阻塞导致死锁的问题呢？ 我们分析一下死锁产生的问题主要是线程都在相互等待其它线程释放资源导致的，基于这个问题我们思考一下，如果一个线程获取不到锁，然后就停止获取锁，不阻塞，或者是阻塞一会就不再阻塞，又或是阻塞过程中被其他线程打断，那样这是不是就不是产生死锁的问题了。 就拿上面的例子来说，假设线程1获取B的阻塞锁超过一定时间，主动放弃获取B的锁，那么线程1代码就可以继续往下执行，当执行完之后，线程1释放了A锁，此时线程2就能获取到A的锁，那么线程2就可以继续执行了，这样是不是死锁的问题就完美解决了。 其实Lock锁就提供了上述提到的几种解决方案的api，接下来我们就来看看Lock锁提供的api。 Lock锁","headline":"为什么Java有了synchronized之后还造了Lock锁这个轮子？","mainEntityOfPage":{"@type":"WebPage","@id":"/cnblog/2022/05/27/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E6%9C%89%E4%BA%86synchronized%E4%B9%8B%E5%90%8E%E8%BF%98%E9%80%A0%E4%BA%86Lock%E9%94%81%E8%BF%99%E4%B8%AA%E8%BD%AE%E5%AD%90.html"},"url":"/cnblog/2022/05/27/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E6%9C%89%E4%BA%86synchronized%E4%B9%8B%E5%90%8E%E8%BF%98%E9%80%A0%E4%BA%86Lock%E9%94%81%E8%BF%99%E4%B8%AA%E8%BD%AE%E5%AD%90.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="dotnet之美" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">dotnet之美</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">为什么Java有了synchronized之后还造了Lock锁这个轮子？</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-05-27T08:36:17+00:00" itemprop="datePublished">May 27, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>众所周知，synchronized和Lock锁是java并发编程中两大利器，可以用来解决线程安全的问题。但是为什么Java有了synchronized之后还是提供了Lock接口这个api，难道仅仅只是重复造了轮子这么简单么？本文就来探讨一下这个问题。</p>

<p>谈到这个问题，其实很多同学第一反应都会说，Lock锁的性能比synchronized好，synchronized属于重量级的锁。但是在JDK 1.6版本之后，JDK对synchronized进行了一系列性能的优化，synchronized的性能其实有了大大的提升（如果不清楚的同学可以看一下 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;amp;mid=2247484124&amp;amp;idx=1&amp;amp;sn=8133290e6dd4c55a310c3d4be1ce0fd7&amp;amp;chksm=cfd95114f8aed802fbdcff8990082ef96195e6b9dcfaf357fc23a0f85045622b8cdaddead1f4&amp;token=667506015&amp;lang=zh_CN#rd">synchronized真的很重么？</a>这篇文章，文章内详细的说明JDK对synchronized做了哪些优化），那么既然性能不是问题，那么主要的问题是什么呢？</p>

<h3 id="synchronized抢占锁的特性">synchronized抢占锁的特性</h3>

<p>我们先来看一下synchronized抢占锁的特性。synchronized在抢占锁的时候，如果抢占不到，线程直接就进入阻塞状态了，而线程进入阻塞状态，其实什么也干不了，也释放不了线程已经占有的资源，并且也无法主动或者被动打断阻塞获取锁的操作，只有等别的线程释放锁之后才会被唤醒来重新获取锁。</p>

<h3 id="synchronized阻塞获取锁产生的问题">synchronized阻塞获取锁产生的问题</h3>

<p>那synchronized这种获取锁阻塞的特性，有什么问题么？其实有一种很重要的问题，那就是会产生死锁的问题。</p>

<p>那什么是死锁？死锁是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待的现象。</p>

<p>举个例子来说，线程1先对加A加锁，线程2对B加锁。代码运行到某一时刻，线程1需要对B加锁，但是此时B的锁已经被线程2占有，于是线程1就会阻塞，与此同时线程2同时也需要对A加锁，发现A已经被线程1持有，也会进入阻塞，于是线程1和线程2都在等对方释放资源，就产生了死锁的问题，并且由于synchronized阻塞的特性，线程无法主动或者被动停止阻塞，势必会导致这个死锁永远无法通过主动或者人为干预（其它线程干预）来解决。</p>

<h3 id="那么有什么好的办法来解决阻塞导致死锁的问题呢">那么有什么好的办法来解决阻塞导致死锁的问题呢？</h3>

<p>我们分析一下死锁产生的问题主要是线程都在相互等待其它线程释放资源导致的，基于这个问题我们思考一下，如果一个线程获取不到锁，然后就停止获取锁，不阻塞，或者是阻塞一会就不再阻塞，又或是阻塞过程中被其他线程打断，那样这是不是就不是产生死锁的问题了。</p>

<p>就拿上面的例子来说，假设线程1获取B的阻塞锁超过一定时间，主动放弃获取B的锁，那么线程1代码就可以继续往下执行，当执行完之后，线程1释放了A锁，此时线程2就能获取到A的锁，那么线程2就可以继续执行了，这样是不是死锁的问题就完美解决了。</p>

<p>其实Lock锁就提供了上述提到的几种解决方案的api，接下来我们就来看看Lock锁提供的api。</p>

<p>Lock锁</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> void lockInterruptibly() throws InterruptedException;
</code></pre></div></div>

<p>阻塞可以被打断的加锁方法，这是一个被动放弃获取锁的方法。就是说其它线程主动当调用阻塞线程的interrupt方法之后，该阻塞线程就会放弃继续获取锁，然后抛出InterruptedException 异常，所以对于使用方来说，只要捕获这个异常，就能保证线程的代码继续执行了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>boolean tryLock();
</code></pre></div></div>

<p>这个方法是尝试加锁，加锁失败后就放弃加锁，不会阻塞，直接返回false。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
</code></pre></div></div>

<p>这个方法相比上面的就是尝试加锁失败后在阻塞的一定时间之后，如果还没有获取到锁，那么就放弃获取锁。</p>

<p>Lock接口的实现有很多，但基本上都是基于Java的AQS的实现来完成的。AQS其实主要是维护了一个锁的状态字段state和一个双向链表。当线程获取锁失败之后，就会加入到双向链表中，然后阻塞或者不阻塞，这得看具体的方法实现。</p>

<p>Lock接口的一个实现ReentrantLock就是基于AQS实现来讲的，这里就不继续展开讲解ReentrantLock的实现原理，如果有感兴趣的同学，可以看一下 <a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;amp;mid=2247484115&amp;amp;idx=1&amp;amp;sn=ae26f9eff454497d6aec66a276b5f3e6&amp;amp;chksm=cfd9511bf8aed80d3ef0e319c8b53b436cb1a294081ace96362524ce12a0d60b2785c72473cf&amp;token=667506015&amp;lang=zh_CN#rd">一文带你看懂Java中的Lock锁底层AQS到底是如何实现的</a> 这篇文章，文章是基于ReentrantLock来讲解AQS的加锁和释放锁的原理。</p>

<h3 id="总结">总结</h3>

<p>好了，到这里其实大家应该知道了，为什么需要Lock锁，因为synchronized获取不到锁的时候会阻塞，并且阻塞不可被打断的特性会导致可能会产生死锁的问题，为了解决这个问题，Java就提供了Lock锁的实现，从主动放弃获取锁或者被动放弃获取锁的方式，解决一直阻塞可能产生的死锁问题。</p>

<p>如果觉得这篇文章对你有所帮助，还请帮忙点赞、在看、转发一下，码字不易，非常感谢！</p>

<p>如果你想联系我，欢迎关注我的个人的微信公众号<strong>三友的java日记</strong>，每天都会发布技术性的文章，期待与你一起进步。</p>

<p><strong>往期热门文章推荐</strong></p>

<ul>
  <li><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;mid=2247485844&amp;idx=1&amp;sn=f9e173c51f4397899470ffbc8eaa3b92&amp;chksm=cfd95a5cf8aed34a3fe68ed8a2fbf420df29a0014a0cbce44c71a7beec0c21fd6285de64f29c&amp;scene=21#wechat_redirect">有关循环依赖和三级缓存的这些问题，你都会么？（面试常问）</a>http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;mid=2247485437&amp;idx=1&amp;sn=d88a7febec0148f5681ca7c728fd8990&amp;chksm=cfd95435f8aedd234a0019f8a0f39832cd2c5a3c7401643e5b666bb141db1fe83e7ea6ab670f&amp;scene=21#wechat_redirect</li>
  <li><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;mid=2247484636&amp;idx=1&amp;sn=834df6a5bf598819d30b2b8f6d42d242&amp;chksm=cfd95714f8aede0210ad9d215b69b25851c17cfb02cab849c6bccea49868b66adda596487b13&amp;scene=21#wechat_redirect">7000字+24张图带你彻底弄懂线程池</a></li>
  <li><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;mid=2247484211&amp;idx=1&amp;sn=13b1cb0832bfae9a6d2369193700fd19&amp;chksm=cfd950fbf8aed9ed473a0e170480770c311f1b637607332a0df15f32e2e9a446f8bc97f0b295&amp;scene=21#wechat_redirect">【SpringCloud原理】OpenFeign原来是这么基于Ribbon来实现负载均衡的</a></li>
  <li><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;mid=2247484202&amp;idx=1&amp;sn=a89f4c393ca2d09b263aab79e4ebfd3d&amp;chksm=cfd950e2f8aed9f4e6f49d93b8120d93382899b7d5eccab06b26c76042abf89a98653410b1d1&amp;scene=21#wechat_redirect">【SpringCloud原理】Ribbon核心组件以及运行原理源码剖析</a></li>
  <li><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;mid=2247484185&amp;idx=1&amp;sn=efb3a1f459be9970126269234ff813e7&amp;chksm=cfd950d1f8aed9c7c9ec6bc8b00c376d9777aa6d6aa2b93ccf6a4b4376adbed8c4f3e1e3754b&amp;scene=21#wechat_redirect">【SpringCloud原理】OpenFeign之FeignClient动态代理生成原理</a></li>
  <li><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MDczNDI0Nw==&amp;mid=2247485444&amp;idx=1&amp;sn=c9c733e84ae5ea499119c49b0fcd4d42&amp;chksm=cfd95bccf8aed2daa4a474af5aa3a6bb087eecdf7a6bcf453431d33bb09fe353b63cd9e1afe4#rd">面渣逆袭：Spring三十五问，四万字+五十图详解！建议收藏！</a></li>
</ul>

<p>扫码关注公众号，及时干货不错过，公众号致力于通过画图加上通俗易懂的语言讲解技术，让技术更加容易学习。</p>

<p><img src="https://img2022.cnblogs.com/blog/2880613/202205/2880613-20220526131552959-1264596689.jpg" alt="" /></p>
<blockquote>
  <p>作者:三友的java日记
原文:https://www.cnblogs.com/zzyang/p/16313085.html</p>
</blockquote>

  </div><a class="u-url" href="/cnblog/2022/05/27/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E6%9C%89%E4%BA%86synchronized%E4%B9%8B%E5%90%8E%E8%BF%98%E9%80%A0%E4%BA%86Lock%E9%94%81%E8%BF%99%E4%B8%AA%E8%BD%AE%E5%AD%90.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">dotnet之美</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">dotnet之美</li><li><a class="u-email" href="mailto:springhgui@outlook.com">springhgui@outlook.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>分享dotnet技术.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
