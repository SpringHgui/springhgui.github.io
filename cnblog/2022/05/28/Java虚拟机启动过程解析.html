<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Java虚拟机启动过程解析 | dotnet之美</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Java虚拟机启动过程解析" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一、序言 当我们在编写Java应用的时候，很少会注意Java程序是如何被运行的，如何被操作系统管理和调度的。带着好奇心，探索一下Java虚拟机启动过程。 1、素材准备 从Java源代码、Java字节码、Java虚拟机、操作系统四个角度分解启动过程。" />
<meta property="og:description" content="一、序言 当我们在编写Java应用的时候，很少会注意Java程序是如何被运行的，如何被操作系统管理和调度的。带着好奇心，探索一下Java虚拟机启动过程。 1、素材准备 从Java源代码、Java字节码、Java虚拟机、操作系统四个角度分解启动过程。" />
<link rel="canonical" href="/cnblog/2022/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html" />
<meta property="og:url" content="/cnblog/2022/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html" />
<meta property="og:site_name" content="dotnet之美" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-28T16:00:33+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Java虚拟机启动过程解析" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-28T16:00:33+00:00","datePublished":"2022-05-28T16:00:33+00:00","description":"一、序言 当我们在编写Java应用的时候，很少会注意Java程序是如何被运行的，如何被操作系统管理和调度的。带着好奇心，探索一下Java虚拟机启动过程。 1、素材准备 从Java源代码、Java字节码、Java虚拟机、操作系统四个角度分解启动过程。","headline":"Java虚拟机启动过程解析","mainEntityOfPage":{"@type":"WebPage","@id":"/cnblog/2022/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html"},"url":"/cnblog/2022/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="dotnet之美" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">dotnet之美</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Java虚拟机启动过程解析</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-05-28T16:00:33+00:00" itemprop="datePublished">May 28, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="一序言">一、序言</h3>

<p>当我们在编写Java应用的时候，很少会注意Java程序是如何被运行的，如何被操作系统管理和调度的。带着好奇心，探索一下Java虚拟机启动过程。</p>

<h5 id="1素材准备">1、素材准备</h5>

<p>从<code class="language-plaintext highlighter-rouge">Java源代码</code>、<code class="language-plaintext highlighter-rouge">Java字节码</code>、<code class="language-plaintext highlighter-rouge">Java虚拟机</code>、<code class="language-plaintext highlighter-rouge">操作系统</code>四个角度分解启动过程。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("HelloWorld!");
    }
}
</code></pre></div></div>

<h5 id="2源代码生成字节码">2、源代码生成字节码</h5>

<p>利用Java环境提供的可执行命令<code class="language-plaintext highlighter-rouge">javac</code>将源代码编译成字节码文件，编译后的字节码文件与平台无关，可跨平台运行。注意区分<code class="language-plaintext highlighter-rouge">javac</code>命令是一个独立的编译应用，源代码编译完成，进程终止。<code class="language-plaintext highlighter-rouge">java</code>命令启动的虚拟机进程的编译过程是将字节码指令编译成汇编指令（二进制指令）。</p>

<h5 id="3虚拟机解析字节码">3、虚拟机解析字节码</h5>

<p>Java字节码无法直接在操作系统上创建进程，因此需要借助已经启动的虚拟机进程来解析字节码，处理字节码有两种常见方式：<code class="language-plaintext highlighter-rouge">解释型</code>和<code class="language-plaintext highlighter-rouge">编译型</code>。</p>

<p>在命令行中每运行<code class="language-plaintext highlighter-rouge">java</code>命令代表启动一个Java虚拟机进程，各虚拟机相互独立，通过命令行参数分别对虚拟机进程进行配置。</p>

<p>Java虚拟机准备启动完毕后，便可以依次解析字节码指令，正式运行<code class="language-plaintext highlighter-rouge">Java代码</code>部分。</p>

<h5 id="4操作系统管理虚拟机">4、操作系统管理虚拟机</h5>

<p>操作系统通过进程管理和调度Java虚拟机，无法感知虚拟机间接解析Java字节码部分。Java字节码通过虚拟机的抽象，完成了在操作系统上运行。</p>

<h3 id="二java虚拟机">二、Java虚拟机</h3>

<p>当运行Java应用时，需要先安装Java环境，然而安装的Java环境与Java应用有什么关系，Java应用是如何运行起来的，下面一探究竟。</p>

<p>二进制可执行程序<code class="language-plaintext highlighter-rouge">${JAVA_HOME}/bin/java</code>是C++编写经过GCC编译器编译后形成的，探索Java虚拟机的运行原理，首先需要找到相应的源码。</p>

<p>当在安装Java环境时，会看到一个<code class="language-plaintext highlighter-rouge">src.zip	</code>压缩文件，解压后里面<code class="language-plaintext highlighter-rouge">launcher/java.c</code>文件便是可执行文件<code class="language-plaintext highlighter-rouge">java</code>命令的主要源码。</p>

<blockquote>
  <p>虚拟机的启动入口位于<code class="language-plaintext highlighter-rouge">launcher/java.c</code>的<code class="language-plaintext highlighter-rouge">main方法</code>，整个流程分为如下几个步骤：  配置JVM装载环境；解析虚拟机参数；设置线程栈大小；执行Java main方法</p>
</blockquote>

<h4 id="一配置jvm装载环境">（一）配置JVM装载环境</h4>

<p>从操作系统加载环境变量、硬件信息等运行环境信息，为后续创建JVM进程做准备。</p>

<h4 id="二命令行参数解析">（二）命令行参数解析</h4>

<p>装载完JVM环境之后，需要对启动时命令行参数进行解析，该过程通过<code class="language-plaintext highlighter-rouge">ParseArguments方法</code>实现，并调用<code class="language-plaintext highlighter-rouge">AddOption方法</code>将解析完成的参数保存到JavaVMOption中。</p>

<p>比如常见的JavaVMOption参数在此步骤解析：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> -Xms：设置堆的初始值InitialHeapSize，也是堆的最小值； 
 -Xmx：设置堆的最大值MaxHeapSize；
</code></pre></div></div>

<p>JVM调优各参数解析便是在此步骤完成的。</p>

<h4 id="三执行main方法">（三）执行main方法</h4>

<p>线程栈大小确定后，通过<code class="language-plaintext highlighter-rouge">ContinueInNewThread方法</code>创建新线程，并执行JavaMain函数，大概流程如下：</p>

<h5 id="1新建jvm实例">1、新建JVM实例</h5>

<p>InitializeJVM方法调用InvocationFunctions的CreateJavaVM方法，即调用JVM.dll函数JNI_CreateJavaVM，新建一个JVM实例，该过程比较复杂。</p>

<h5 id="2加载入口类">2、加载入口类</h5>

<p>通常在命令行中运行如下命令即指明入口类路径</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 直接指名入口类路径
java HelloWorld.class
# 通过包类配置入口类路径
java -jar HelloWorld.jar
</code></pre></div></div>

<h5 id="3查找main方法">3、查找main方法</h5>

<p>通过GetStaticMethodID方法查找指定main方法名的静态方法。</p>

<h5 id="4执行main方法">4、执行main方法</h5>

<p>通过<code class="language-plaintext highlighter-rouge">JavaCalls::call</code>回调执行main方法。需要注意的是，这里执行main方法不是Java语言的方法，是经过虚拟机解释（或者编译）后，操作系统能够理解的二进制可执行方法。</p>

<h3 id="三解析字节码">三、解析字节码</h3>

<h4 id="一解释字节码">（一）解释字节码</h4>

<h5 id="1基于栈指令集">1、基于栈指令集</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iconst_1    将 1 放入栈顶
iconst_1    将 1 放入栈顶
iadd        将栈顶的 2 个数相加后结果放入栈顶
istore_0    将相加的结果放入局部变量表
</code></pre></div></div>

<p>基于栈的指令集优点是虚拟机解释器是可跨平台移植的，换句话说不同平台的虚拟机解释器代码可以复用。</p>

<h5 id="2基于寄存器指令集">2、基于寄存器指令集</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov eax,1 把 EAX 寄存器的值设为 1
add eax,1 再把这个值加 1 ，结果保存在了 EAX 寄存器
</code></pre></div></div>

<p>基于寄存器指令集的优点是执行速度相对于栈较快，原因是出栈入栈本身就涉及了大量的指令，而且栈是在内存中实现的，更底层的汇编指令性能更高。</p>

<p>基于寄存器指令集的缺点是虚拟机解释器是不可跨平台移植，需要针对不同平台的虚拟机做不同实现。考虑到不同平台已经使用不同的虚拟机程序，因此此过程多用户透明。</p>

<hr />

<p>虚拟机通过解释器来翻译字节码文件中的指令比较顺其自然，可是对于服务器端高频执行的程序来说，中间的翻译过程相对耗时。解释字节码的方式适用于对启动性能要求高，并且执行频率较低的应用程序。</p>

<h4 id="二编译字节码">（二）编译字节码</h4>

<p>最初，JVM 中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为<code class="language-plaintext highlighter-rouge">热点代码</code>。</p>

<p>为了提高热点代码的执行效率，在运行时，即时编译器（JIT，Just In Time）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中。</p>

<p>在 HotSpot 虚拟机中，内置了两种 JIT，分别为<code class="language-plaintext highlighter-rouge">C1 编译器</code>和<code class="language-plaintext highlighter-rouge">C2 编译器</code>，这两个编译器的编译过程是不一样的。</p>

<h5 id="1c1-编译器">1、C1 编译器</h5>

<p>C1 编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，也称为<code class="language-plaintext highlighter-rouge">Client Compiler</code>，例如，GUI 应用对界面启动速度就有一定要求。</p>

<h5 id="2c2-编译器">2、C2 编译器</h5>

<p>C2 编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，也称为<code class="language-plaintext highlighter-rouge">Server Compiler</code>，例如，服务器上长期运行的 Java 应用对稳定运行就有一定的要求。</p>

<h5 id="3分层编译">3、分层编译</h5>

<p>分层编译将 JVM 的执行状态分为了 5 个层次：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>第 0 层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译；
第 1 层：可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；
第 2 层：也称为 C1 编译，开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；
第 3 层：也称为 C1 编译，执行所有带 Profiling 的 C1 编译；
第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。
</code></pre></div></div>

<p>通常情况下，C2 的执行效率比 C1 高出30%以上。</p>

<p>在 Java8 中，默认开启分层编译。如果只想开启 C2，可以关闭分层编译（<code class="language-plaintext highlighter-rouge">-XX:-TieredCompilation</code>），如果只想用 C1，可以在打开分层编译的同时，使用参数：<code class="language-plaintext highlighter-rouge">-XX:TieredStopAtLevel=1</code>。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">java -version</code>命令行可以查看到当前虚拟机解析字节码的方式，<code class="language-plaintext highlighter-rouge">mixed mode</code>表示既有解释模式也有即是编译模式。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mixed mode</code>代表是默认的混合编译模式，除了这种模式外，我们还可以使用<code class="language-plaintext highlighter-rouge">-Xint</code>参数强制虚拟机运行于只有解释器的编译模式下；也可以使用参数<code class="language-plaintext highlighter-rouge">-Xcomp</code>强制虚拟机运行于只有 JIT 的编译模式下。</p>

<p><strong>仅使用解释模式</strong></p>

<p>通过命令<code class="language-plaintext highlighter-rouge">java -Xint -version</code>设置仅使用解释模式，<code class="language-plaintext highlighter-rouge">interpreted mode</code>表示解释模式。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, interpreted mode)
</code></pre></div></div>

<p><strong>仅使用编译模式</strong></p>

<p>通过命令<code class="language-plaintext highlighter-rouge">java -Xcomp -version</code>设置仅使用编译模式，<code class="language-plaintext highlighter-rouge">compiled mode</code>表示编译模式。在编译模式下，程序启动能感觉到明显的卡顿。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, compiled mode)
</code></pre></div></div>

<h3 id="四小结">四、小结</h3>

<p>通过对Java虚拟机启动过程的解析，特别是<code class="language-plaintext highlighter-rouge">即时编译</code>环节的理解，Java应用运行并不慢。当应用中热点代码普遍被编译成汇编指令（二进制可执行命令）存放于内存中时，可近似达到C语言原生程序的运行速度。</p>

<p>随着算力与内存成本日渐降低，通过空间复杂度置换时间复杂度的策略显然是合理的，使用Java语言编写需求万千变化的应用是第一选择：既有跨平台、内存安全、框架生态丰富的优点，也在运行效率方面积极改善，这种折中选择与市场反馈保持一致。</p>
<blockquote>
  <p>作者:Java知识图谱<br />
原文:https://www.cnblogs.com/javazhishitupu/p/16316869.html</p>
</blockquote>

  </div><a class="u-url" href="/cnblog/2022/05/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">dotnet之美</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">dotnet之美</li><li><a class="u-email" href="mailto:springhgui@outlook.com">springhgui@outlook.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>分享dotnet技术.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
